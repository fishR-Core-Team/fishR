{
  "hash": "ff294d4a6a29b4a7b5fc6a5235389cec",
  "result": {
    "markdown": "---\ntitle: Working with Multiple Age-Length Keys\ndescription: Computing and applying age-length keys at once for multiple groups.\nauthor: Derek H. Ogle\ndate: 4/23/2023\nimage: preview.png\ncategories:\n  - Data Wrangling\n  - Age-Length Key\n  - purr\n---\n\n\n# Introduction\nAn age-length key (ALK) describes the relationship between length (category) and age of fish. An estimated age may be assigned to unaged fish in a sample based on the ALK derived from aged fish from the same (or very closely related) sample as described by @isermannknight_2005 and implemented in the `FSA` package [@ogleIntroductoryFisheriesAnalyses2016]. It is critical to this process that the ALK is representative of the fish to which ages will be assigned. Thus, for example, it is not recommended to use an ALK developed from fish collected in one year to assign age to fish collected in another year, or for fish collected from different areas.\n\nThis recommendation can lead to cumbersome data wrangling during analysis. For example, suppose that samples of fish were collected from two different areas over a five year period. In this case separate age-length keys would be required to be developed and applied to the ten combinations of locations and years. For each location-year the specific data would need to be isolated and for that data the ALK developed and applied, which has several steps as was shown in @ogleIntroductoryFisheriesAnalyses2016 and will be outlined below. The final data produced for each location-year would then need to be combined back together to make an overall data set. In other words, using the @isermannknight_2005 method to assign estimated ages to unaged fish for multiple groups of fish is quite a bit of work. The goal of this post is to provide a more efficient method to accomplish this task.\n\nThe following packages are loaded for use below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)  # for dplyr, tidyr, purr packages\nlibrary(FSA)        # for ALK functionality\n```\n:::\n\n\nThe random number seed was set to ensure repeatability for the random components of `alkIndivAge()` below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(14354454)\n```\n:::\n\n\n&nbsp;\n\n# Age-Length Keys in FSA\n### Original Example from Ogle (2016)\n@ogleIntroductoryFisheriesAnalyses2016 demonstrated how to use the @isermannknight_2005 method to assign ages to unaged Creek Chubs (*Semotilus atromaculatus*). The portion of the script used there to produce a final data frame with ages for all sampled fish is shown below.^[This code was extracted from the script provided [here](https://derekogle.com/IFAR/). It is slightly modified here to maintain the original unaltered data frame in `cc`.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncc <- read.csv(\"https://derekogle.com/IFAR/scripts/CreekChub.csv\")\ncc1 <- cc |> mutate(lcat10=lencat(len,w=10))\ncc1.unaged <- filter(cc1,is.na(age))\ncc1.aged <- filter(cc1,!is.na(age))\nalk.freq <- xtabs(~lcat10+age,data=cc1.aged)\nalk <- prop.table(alk.freq,margin=1)\ncc1.unaged.mod <- alkIndivAge(alk,age~len,data=cc1.unaged)\ncc1.fnl <- rbind(cc1.aged,cc1.unaged.mod)\n```\n:::\n\n\nThe lengths-at-age in this final data frame were summarized in @ogleIntroductoryFisheriesAnalyses2016 as follows.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncc1.fnl |>\n  group_by(age) |>\n  summarize(n=FSA::validn(len),\n            mn=mean(len,na.rm=TRUE),\n            sd=sd(len,na.rm=TRUE),\n            se=FSA::se(len,na.rm=TRUE)) |>\n  as.data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|    age   n        mn       sd       se\n#R|  1   0  20  48.65000  5.62209 1.257138\n#R|  2   1 142  74.64789 16.82163 1.411640\n#R|  3   2  43 113.41860 15.77405 2.405520\n#R|  4   3   8 151.87500 11.17954 3.952565\n#R|  5   4   5 183.20000 17.25399 7.716217\n```\n:::\n:::\n\n\n### Simplifying Function\nI have resisted writing a function that would combine all of the steps above, as I did not want to create a \"black-box\" function for this analysis that could be implemented without much thought. However, such a function would be useful for efficiently applying ALKs to multiple groups of fish. Thus, I create such a function and demonstrate how it can be used to produce the same^[At least within rounding because of the inherent randomization in the @isermannknight_2005 method.] results as those shown for Creek Chub in @ogleIntroductoryFisheriesAnalyses2016. In the next section, I demonstrate how this new function can then be used to efficiently apply ALKs for multiple groups of fish.\n\nThe `applyALK()` function created below performs the code shown above to create a \"final\" data frame that has ages assigned to the unaged fish based on the ALK. The function largely repeats the code above but uses some \"advanced\" code (e.g., `deparse(substitute())` and `{{}}`) to handle the use of unquoted variables names.^[This allows the variable names to be supplied by user in the function call, rather than hard-coded in the function.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Computes and applies an ALK\n##   data: The data frame with, at least, the age & length variables\n##   avar: The name (without quotes) of the age variable in data\n##   lvar: The name (without quotes) of the length variable in data\n##   w: The width of length categories/bins for use in the ALK\n## Returns the data data frame with ages in avar assigned from the ALK for\n##   unaged fish and a new length category (lcat) variable derived from w\n\napplyALK <- function(data,avar,lvar,w) {\n  ## Get avar variable name as character for non-tidyverse functions below\n  avarn <- deparse(substitute(avar))\n  ## Add length category variable\n  data <- data |> dplyr::mutate(lcat=FSA::lencat({{lvar}},w=w))\n  ## Separate into aged and unaged dataframes\n  aged <- data |> dplyr::filter(!is.na({{avar}}))\n  unaged <- data |> dplyr::filter(is.na({{avar}}))\n  ## Make ALK (find frequencies, convert to row proportions)\n  ALK <- prop.table(xtabs(as.formula(paste0(\"~lcat+\",avarn)),data=aged),margin=1)\n  ## Apply ALK according to Isermann-Knight method\n  tmp <- FSA::alkIndivAge(ALK,as.formula(paste0(avarn,\"~lcat\")),data=unaged)\n  ## Put aged and newly assigned age data frames together to return\n  dplyr::bind_rows(aged,tmp)\n}\n```\n:::\n\n\nWith this new function the final data frame can be created by supplying the original data frame (with aged and unaged fish) as the first argument, the names of the age and length variables in `avar=` and `lvar=` respectively, and the width for the length categories/bins in `w=`. For example, the final data frame for the Creek Chub case study can be created as follows.^[Note the use the original `cc` data frame without the length categorization variable.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncc.fnl <- applyALK(cc,avar=age,lvar=len,w=10)\n```\n:::\n\n\nThe lengths-at-age summary for this final data frame is similar^[Again, not exact because of the inherent randomization in the @isermannknight_2005 method.] to that from @ogleIntroductoryFisheriesAnalyses2016 as repeated above.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncc.fnl |>\n  group_by(age) |>\n  summarize(n=FSA::validn(len),\n            mn=mean(len,na.rm=TRUE),\n            sd=sd(len,na.rm=TRUE),\n            se=FSA::se(len,na.rm=TRUE)) |>\n  as.data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|    age   n        mn        sd       se\n#R|  1   0  20  48.95000  6.012925 1.344531\n#R|  2   1 142  74.66197 16.955046 1.422836\n#R|  3   2  43 113.23256 15.929663 2.429251\n#R|  4   3   8 151.87500 11.179541 3.952565\n#R|  5   4   5 183.20000 17.253985 7.716217\n```\n:::\n:::\n\n\n:::{.callout-important}\nOne still needs to carefully consider the application of ALKs for each of the groups. For example, if the minimum length of unaged fish is less than the minimum length of aged fish (i.e., smaller than that which the ALK is based on) for any one group then this process will fail for ALL groups. In other words a complete fail will occur if there is a fail for any one group in the analysis.\n:::\n\n&nbsp;\n\n# Efficiently Applying ALKs to Multiple Groups\n### Example Data\n@schalletal_2020 examined the effect of season (Spring and Fall) on the vital statistics of Channel Catfish (*Ictalurus punctatus*) and Walleye (*Sander vitreus*) in a large Nebraska reservoir. One part of their analysis required computing mortality rates from catch curves for each species and season combination. Prior to constructing the catch curve they used the @isermannknight_2005 method to assign estimated ages to unaged fish. @schalletal_2020 provided the raw data as a CSV file in their Supplement Material Data S1. Note that I removed some variables just for simplicity of presentation in this post and that their `Month` completely defined `Season`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat <- read.csv(\"JFWM-20-027.S1.csv\") |>\n  select(-Weight,-Sex,-BCAge,-BCLength) |>\n  mutate(Season=case_when(\n    Month==\"May\" ~ \"Spring\",\n    Month==\"September\" ~ \"Fall\"\n  ))\nheadtail(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|       Spp Length Year     Month Age Season\n#R|  1    CCF    279 2015       May   3 Spring\n#R|  2    CCF    334 2015       May   4 Spring\n#R|  3    CCF    351 2015       May   4 Spring\n#R|  2377 WAE     NA 2016 September  NA   Fall\n#R|  2378 WAE     NA 2016 September  NA   Fall\n#R|  2379 WAE     NA 2016 September  NA   Fall\n```\n:::\n:::\n\n\nWhile it is not clear from their methods, I assume that they used a separate ALK for each species and season combination.\n\nA common \"issue\" with using the ALK to assign ages to unaged fish is that the lengths of some unaged fish are not represented within the lengths of aged fish used to derive the ALK. In other words, the ALK does not contain information for fish of those lengths. The summary below is used to find the sample size and valid sample size (i.e., after excluding fish with no length measurement) and minimum and maximum length for each combination of species, season, and whether an age was assigned or not.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat |>\n  mutate(Aged=!is.na(Age)) |>\n  group_by(Spp,Season,Aged) |>\n  summarize(n=n(),\n            validn=validn(Length),\n            minL=min(Length,na.rm=TRUE),\n            maxL=max(Length,na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  # A tibble: 8 × 7\n#R|  # Groups:   Spp, Season [4]\n#R|    Spp   Season Aged      n validn  minL  maxL\n#R|    <chr> <chr>  <lgl> <int>  <int> <int> <int>\n#R|  1 CCF   Fall   FALSE   105    104   197   674\n#R|  2 CCF   Fall   TRUE     97     97   200   724\n#R|  3 CCF   Spring FALSE   394    393   260   733\n#R|  4 CCF   Spring TRUE    104    104   279   769\n#R|  5 WAE   Fall   FALSE   883    870   181   634\n#R|  6 WAE   Fall   TRUE    466    466   157   676\n#R|  7 WAE   Spring FALSE   117    116   332   724\n#R|  8 WAE   Spring TRUE    213    213   191   753\n```\n:::\n:::\n\n\nIt is seen from this that there are some missing length measurements (`n` does not equal `validn` in all cases) and that the minimum length of unaged fish is less than the minimum length of aged fish for Channel Catfish in both the Spring and Fall. Thus, to appropriately use the @isermannknight_2005 method as implemented in `alkIndivAge()` of `FSA` with these data, those records with missing lengths must be removed, as well as those records for Channel Catfish that are less than the minimum length for aged Channel Catfish in their respective season.^[It is not clear that @schalletal_2020 did this, but it is required when using `alkIndivAge()`.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat <- dat |>\n  filter(!is.na(Length)) |>\n  filter(!(Spp==\"CCF\" & Season==\"Spring\" & Length<279)) |>\n  filter(!(Spp==\"CCF\" & Season==\"Fall\" & Length<200))\n```\n:::\n\n\n### Method-Specific Data Wrangling\nThe first step in efficiently applying the ALK to all groups is to \"split\" the original data frame based on the \"groups\" with `split()`. Below `dat` is split by the combination of `Spp` (species) and `Season`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat2 <- split(dat,~Spp+Season)\n```\n:::\n\n\nThe result, in `dat2`, is a list with four items. Each item in the list is a data frame with the same structure as the original `dat` but reduced to a specific group defined by `Spp` and `Season`. Below `names()` is used to show that the names of the four items in `dat2` are combinations of the \"levels\" in `Spp` and `Season`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnames(dat2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  [1] \"CCF.Fall\"   \"WAE.Fall\"   \"CCF.Spring\" \"WAE.Spring\"\n```\n:::\n:::\n\n\nThe specifics of one of these items is examined by appending one of the item names to `dat2`, separated by a `$`. Below, as an example, are a few rows from the beginning and end of the data frame in the `CCF.Spring` (Channel Catfish in Spring) item. Note here that it appears that all `Spp` values are \"CCF\", all `Season` values are \"Spring\", and that some fish have ages (the top three) and some do not (the bottom three).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nheadtail(dat2$CCF.Spring)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|      Spp Length Year Month Age Season\n#R|  1   CCF    279 2015   May   3 Spring\n#R|  2   CCF    334 2015   May   4 Spring\n#R|  3   CCF    351 2015   May   4 Spring\n#R|  491 CCF    701 2015   May  NA Spring\n#R|  492 CCF    730 2015   May  NA Spring\n#R|  493 CCF    733 2015   May  NA Spring\n```\n:::\n:::\n\n\n### Applying ALK\nThe idea now is to \"apply\" `applyALK()` to each data frame in each item of the list in `dat2`. This can be done with `lapply()` where the list is the first argument, the function to apply is the second argument, and the remaining arguments are further arguments to the function in the second argument. The result is a list with data frames in the items as before, but now with ages for all fish.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat3 <- lapply(dat2,applyALK,avar=Age,lvar=Length,w=10)\nnames(dat3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  [1] \"CCF.Fall\"   \"WAE.Fall\"   \"CCF.Spring\" \"WAE.Spring\"\n```\n:::\n\n```{.r .cell-code}\nheadtail(dat3$CCF.Spring)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|      Spp Length Year Month Age Season lcat\n#R|  1   CCF    279 2015   May   3 Spring  270\n#R|  2   CCF    334 2015   May   4 Spring  330\n#R|  3   CCF    351 2015   May   4 Spring  350\n#R|  491 CCF    701 2015   May  17 Spring  700\n#R|  492 CCF    730 2015   May  17 Spring  730\n#R|  493 CCF    733 2015   May  17 Spring  730\n```\n:::\n:::\n\n\nThe exact same result^[Disregarding the randomization inherent in `alkIndivAge()`.] is also obtained with `map()` from the `purr` package, which was loaded with `library(tidyverse)`. The arguments to `map()` and the resulting list are the same as those for `lapply()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat3 <- map(dat2,applyALK,avar=Age,lvar=Length,w=10)\nnames(dat3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  [1] \"CCF.Fall\"   \"WAE.Fall\"   \"CCF.Spring\" \"WAE.Spring\"\n```\n:::\n\n```{.r .cell-code}\nheadtail(dat3$CCF.Spring)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|      Spp Length Year Month Age Season lcat\n#R|  1   CCF    279 2015   May   3 Spring  270\n#R|  2   CCF    334 2015   May   4 Spring  330\n#R|  3   CCF    351 2015   May   4 Spring  350\n#R|  491 CCF    701 2015   May  17 Spring  700\n#R|  492 CCF    730 2015   May  17 Spring  730\n#R|  493 CCF    733 2015   May  17 Spring  730\n```\n:::\n:::\n\n\nThe reason for introducing `map()` from `purr()` is that ultimately the four data frames in `dat3` need to be \"row-bound\" together to form a single data frame. There are multiple ways to do this, but the simplest is to use `map_df()` from `purr`. `map_df()` has the same arguments as `map()` and `lapply()` but it returns a single combined data frame, rather than a list with multiple data frames.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat3 <- map_df(dat2,applyALK,avar=Age,lvar=Length,w=10)\nnames(dat3)  # now column names of the single data frame\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  [1] \"Spp\"    \"Length\" \"Year\"   \"Month\"  \"Age\"    \"Season\" \"lcat\"\n```\n:::\n\n```{.r .cell-code}\nheadtail(dat3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|       Spp Length Year     Month Age Season lcat\n#R|  1    CCF    232 2016 September   1   Fall  230\n#R|  2    CCF    216 2016 September   1   Fall  210\n#R|  3    CCF    238 2016 September   1   Fall  230\n#R|  2355 WAE    632 2015       May  10 Spring  630\n#R|  2356 WAE    653 2015       May  10 Spring  650\n#R|  2357 WAE    720 2015       May  13 Spring  720\n```\n:::\n:::\n\n\n:::{.callout-warning}\nThe process, as shown above, will not handle situations where the length category bin width required differs among the groups.\n:::\n\n&nbsp;\n\n# Preview - Summaries\nWhile there are still some issues to deal with before the mortality rate can be estimated via catch curve with these data, the summary table and graphic below provide an indication of how the final result from above can be visualized. The issue of estimating mortality rate from these data will be taken up in [the next post](../2023-4-24_Multiple_CatchCurves/).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsumdat1 <- dat3 |>\n  group_by(Spp,Season,Age) |>\n  summarize(Catch=n(),\n            meanL=mean(Length),\n            sdL=sd(Length))\nsumdat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  # A tibble: 53 × 6\n#R|  # Groups:   Spp, Season [4]\n#R|     Spp   Season   Age Catch meanL   sdL\n#R|     <chr> <chr>  <dbl> <int> <dbl> <dbl>\n#R|   1 CCF   Fall       1    15  227.  14.7\n#R|   2 CCF   Fall       2    22  262.  37.7\n#R|   3 CCF   Fall       3     3  309   27.7\n#R|   4 CCF   Fall       4    16  359.  15.4\n#R|   5 CCF   Fall       5    30  384.  37.5\n#R|   6 CCF   Fall       6    21  405.  23.4\n#R|   7 CCF   Fall       7    22  430.  25.1\n#R|   8 CCF   Fall       8    29  449.  40.6\n#R|   9 CCF   Fall       9    22  488.  40.3\n#R|  10 CCF   Fall      10    11  495.  29.5\n#R|  # … with 43 more rows\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(dat=sumdat1,mapping=aes(x=Age,y=Catch,color=Season)) +\n  geom_point(size=2) +\n  geom_line(alpha=0.1,linewidth=1.5) +\n  scale_x_continuous(name=\"Age (yrs)\",expand=expansion(mult=0.02)) +\n  scale_y_continuous(name=\"Total Catch\",expand=expansion(mult=0.02),\n                     trans=\"log\",breaks=c(1,2,5,10,20,50,100,200,500)) +\n  facet_wrap(vars(Spp)) +\n  theme_bw() +\n  theme(panel.grid.major=element_blank(),\n        legend.position=c(1,1),\n        legend.justification=c(1.1,1.1),\n        legend.title=element_blank(),\n        legend.background=element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/data-sum-3-1.png){fig-align='center' width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}