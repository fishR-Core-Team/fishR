{
  "hash": "98774982edd17131f8ccd5de19eb2ee6",
  "result": {
    "markdown": "---\ntitle: Working with Multiple Catch Curves\ndescription: Computing mortality from catch curves for multiple groups.\nauthor: Derek H. Ogle\ndate: 4/24/2023\nimage: preview.png\ncategories:\n  - Data Wrangling\n  - Age-Length Key\n  - Mortality\n  - Catch Curve\n  - purr\n---\n\n\n# Introduction\nIn [a previous post](../2023-4-23_Multiple_ALKs/) a helper function was created and some of the `map` family of functions from `purr` were used to efficiently create and apply an age-length key (ALK) to assign estimated ages to unaged fish in a sample. That post will be extended here by using functions from `purr` and `FSA` to efficiently compute mortality estimates from catch curves for multiple groups of fish.\n\nThe following packages are loaded for use below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)  # for dplyr, tidyr, purr packages\nlibrary(FSA)        # for catchCurve functionality\n```\n:::\n\n\nThe random number seed was set to ensure repeatability for the random components of `alkIndivAge()` below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(14354454)\n```\n:::\n\n\n&nbsp;\n\n# Initial Wrangling & Catch-at-Age Summary\nThis post begins with the final data frame from [the previous post](../2023-4-23_Multiple_ALKs/) of lengths and ages for all sampled Channel Catfish (*Ictalurus punctatus*) and Walleye (*Sander vitreus*) data. A portion of the resultant data frame is shown below, but the code is folded to save space.^[Please see the previous post for a thorough description of this process.] Note here that the final data frame is called `dat`.^[Rather than `dat3` as in the previous post.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\n## Computes and applies an ALK\n##   data: The data frame with, at least, the age & length variables\n##   avar: The name (without quotes) of the age variable in data\n##   lvar: The name (without quotes) of the length variable in data\n##   w: The width of length categories/bins for use in the ALK\n## Returns the data data frame with ages in avar assigned from the ALK for\n##   unaged fish and a new length category (lcat) variable derived from w\n\napplyALK <- function(data,avar,lvar,w) {\n  ## Get avar variable name as character for non-tidyverse functions below\n  avarn <- deparse(substitute(avar))\n  ## Add length category variable\n  data <- data |> dplyr::mutate(lcat=FSA::lencat({{lvar}},w=w))\n  ## Separate into aged and unaged dataframes\n  aged <- data |> dplyr::filter(!is.na({{avar}}))\n  unaged <- data |> dplyr::filter(is.na({{avar}}))\n  ## Make ALK (find frequencies, convert to row proportions)\n  ALK <- prop.table(xtabs(as.formula(paste0(\"~lcat+\",avarn)),data=aged),margin=1)\n  ## Apply ALK according to Isermann-Knight method\n  tmp <- FSA::alkIndivAge(ALK,as.formula(paste0(avarn,\"~lcat\")),data=unaged)\n  ## Put aged and newly assigned age data frames together to return\n  dplyr::bind_rows(aged,tmp)\n}\n\n## Wrangle the data\ndat <- read.csv(\"../2023-4-23_Multiple_ALKs/JFWM-20-027.S1.csv\") |>\n  select(-Weight,-Sex,-BCAge,-BCLength,-Year) |>\n  mutate(Season=case_when(\n    Month==\"May\" ~ \"Spring\",\n    Month==\"September\" ~ \"Fall\"\n  )) |>\n  filter(!is.na(Length)) |>\n  filter(!(Spp==\"CCF\" & Season==\"Spring\" & Length<279)) |>\n  filter(!(Spp==\"CCF\" & Season==\"Fall\" & Length<200)) |>\n  split(~Spp+Season) |>\n  map_df(applyALK,avar=Age,lvar=Length,w=10) |>\n  select(Spp,Season,Age,Length,lcat)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nheadtail(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|       Spp Season Age Length lcat\n#R|  1    CCF   Fall   1    232  230\n#R|  2    CCF   Fall   1    216  210\n#R|  3    CCF   Fall   1    238  230\n#R|  2355 WAE Spring  10    632  630\n#R|  2356 WAE Spring  10    653  650\n#R|  2357 WAE Spring  13    720  720\n```\n:::\n:::\n\n\nThese data are summarized to provide total catches at each **OBSERVED** age for each species and season combination.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nCatAge <- dat |>\n  group_by(Spp,Season,Age) |>\n  summarize(Catch=n()) |>\n  ungroup()\nCatAge\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  # A tibble: 53 × 4\n#R|     Spp   Season   Age Catch\n#R|     <chr> <chr>  <dbl> <int>\n#R|   1 CCF   Fall       1    15\n#R|   2 CCF   Fall       2    22\n#R|   3 CCF   Fall       3     3\n#R|   4 CCF   Fall       4    16\n#R|   5 CCF   Fall       5    29\n#R|   6 CCF   Fall       6    23\n#R|   7 CCF   Fall       7    20\n#R|   8 CCF   Fall       8    29\n#R|   9 CCF   Fall       9    22\n#R|  10 CCF   Fall      10    12\n#R|  # … with 43 more rows\n```\n:::\n:::\n\n\nA quick summary of the age range and number of observed ages for each species and season combination indicates that some ages within the age range were **not** observed.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nCatAge |>\n  group_by(Spp,Season) |>\n  summarize(agerng=max(Age)-min(Age)+1,\n            agesobs=n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  # A tibble: 4 × 4\n#R|  # Groups:   Spp [2]\n#R|    Spp   Season agerng agesobs\n#R|    <chr> <chr>   <dbl>   <int>\n#R|  1 CCF   Fall       17      14\n#R|  2 CCF   Spring     16      14\n#R|  3 WAE   Fall       11      10\n#R|  4 WAE   Spring     18      15\n```\n:::\n:::\n\n\nFor example, the age range for Channel Catfish in the Fall was from 1 to 17, but no age 12, 13, or 16 fish were caught.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nCatAge |> filter(Spp==\"CCF\",Season==\"Fall\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  # A tibble: 14 × 4\n#R|     Spp   Season   Age Catch\n#R|     <chr> <chr>  <dbl> <int>\n#R|   1 CCF   Fall       1    15\n#R|   2 CCF   Fall       2    22\n#R|   3 CCF   Fall       3     3\n#R|   4 CCF   Fall       4    16\n#R|   5 CCF   Fall       5    29\n#R|   6 CCF   Fall       6    23\n#R|   7 CCF   Fall       7    20\n#R|   8 CCF   Fall       8    29\n#R|   9 CCF   Fall       9    22\n#R|  10 CCF   Fall      10    12\n#R|  11 CCF   Fall      11     2\n#R|  12 CCF   Fall      14     1\n#R|  13 CCF   Fall      15     2\n#R|  14 CCF   Fall      17     3\n```\n:::\n:::\n\n\n@schalletal_2020 assumed a catch of 0 for ages that were not observed within the range of observed ages for each species and season. Thus, the first \"issue\" encountered with these data was how to insert 0s into the data frames for these \"unobserved\" ages.\n\n# Handling Zero Catches\n### A Helper Function\nA helper function, `add0CatchByAge()`, was created to facilitate the adding of zero catches for the appropriate ages. This function looks complicated because I chose to allow the age and catch variables to be given without quotes. However, the general algorithm in this function is to use `full_seq()` from `tidyr` to create a sequence of sequential ages over the range of observed ages, then use `left_join()` from `dplyr` to join the original data frame to the sequence of ages, and use `remove_na()` from `tidyr` to replace missing \"catch\" data with zero and missing non-age and non-catch data with values from the first row of the original data frame. It is important to note that this function will **only work if the non-age and non-catch variables are constant across rows.**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Adds a row with catch=0 for unobserved ages within the range of observed ages\n##   data: The data frame with, at least, the age & catch variables\n##   avar: The name (without quotes) of the age variable in data\n##   cvar: The name (without quotes) of the catch variable in data\n##   fill: The value to use for the catch of unobserved ages (defaults to 0)\n## Returns the data data frame with previoulsy unobserved ages in avar, the fill\n##   value for those ages in cvar, and values in other variables repeated for\n##   those ages\n\nadd0CatchByAge <- function(data,avar,cvar,fill=0L) {\n  ## Get variable names as characters for non-tidyverse functions\n  avarn <- deparse(substitute(avar))\n  cvarn <- deparse(substitute(cvar))\n  ## Get names of variables in data\n  dnms <- names(data) # all\n  dnms2 <- dnms[!dnms %in% c(avarn,cvarn)]\n  ## Create sequence of ages that cover full range of ages\n  tmpages <- data.frame(tidyr::full_seq(as.data.frame(data)[,avarn],1))\n  names(tmpages) <- avarn\n  ## Create fill list for unobserved ages\n  fills <- c(as.list(data[1,dnms2]),fill)\n  names(fills) <- c(dnms2,cvarn)  \n  ## Add zeroes to ages not observed\n  tmp <- dplyr::left_join(tmpages,data,by=avarn) |>\n    tidyr::replace_na(fills)\n  ## Return data frame with columns ordered as in original data\n  tmp[,dnms]\n}\n```\n:::\n\n\n`add0CatchByAge()` takes a data frame (with at least age and catch variables) as the first argument, unquoted names for \"age\" and \"catch\" variables in `avar=` and `cvar=`, and the value to fill in for the catch of unobserved ages in `fill=` (defaults to 0). The example below shows how zeroes are filled in for the unobserved ages of Channel Catfish captured in the Fall.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntmpex <- CatAge |> filter(Spp==\"CCF\",Season==\"Fall\") ## temporary data frame for example\nadd0CatchByAge(tmpex,avar=Age,cvar=Catch)            ## example result\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|     Spp Season Age Catch\n#R|  1  CCF   Fall   1    15\n#R|  2  CCF   Fall   2    22\n#R|  3  CCF   Fall   3     3\n#R|  4  CCF   Fall   4    16\n#R|  5  CCF   Fall   5    29\n#R|  6  CCF   Fall   6    23\n#R|  7  CCF   Fall   7    20\n#R|  8  CCF   Fall   8    29\n#R|  9  CCF   Fall   9    22\n#R|  10 CCF   Fall  10    12\n#R|  11 CCF   Fall  11     2\n#R|  12 CCF   Fall  12     0\n#R|  13 CCF   Fall  13     0\n#R|  14 CCF   Fall  14     1\n#R|  15 CCF   Fall  15     2\n#R|  16 CCF   Fall  16     0\n#R|  17 CCF   Fall  17     3\n```\n:::\n:::\n\n\n### Adding the Zeroes\nAdding the zeroes must be done on a *per-group* basis, which is by species-season combination here. Thus, the `CatAge` summary data frame is `split()` by `Spp` and `Season` into a list of four data frames.^[The process of using `split()` was defined more thoroughly in [this post](../2023-4-23_Multiple_ALKs/).] This list of data frames is then given to `map_df()` which applies `add0CatchByAge()` to each of the four data frames using `Age` for `avar=` and `Catch` for `cvar=`. The four data frames are then row-bound together to return one overall data frame.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nCatAge <- CatAge |>\n  split(~Spp+Season) |>\n  map_df(add0CatchByAge,avar=Age,cvar=Catch)\nheadtail(CatAge)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|     Spp Season Age Catch\n#R|  1  CCF   Fall   1    15\n#R|  2  CCF   Fall   2    22\n#R|  3  CCF   Fall   3     3\n#R|  60 WAE Spring  16     2\n#R|  61 WAE Spring  17     0\n#R|  62 WAE Spring  18     2\n```\n:::\n:::\n\n\nThe result is a single data frame with the same variables as the original `CatAge`, but with new rows of `Catch`=0 for unobserved `Age`s. This is best seen by examining the portion of the new `CatAge` summary data frame for Channel Catfish captured in the Fall.\n\n\n::: {.cell layout-align=\"center\" output-line-numbers='1,13,14,17'}\n\n```{.r .cell-code}\nCatAge |> filter(Spp==\"CCF\",Season==\"Fall\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.highlight .numberLines}\n#R|     Spp Season Age Catch\n#R|  1  CCF   Fall   1    15\n#R|  2  CCF   Fall   2    22\n#R|  3  CCF   Fall   3     3\n#R|  4  CCF   Fall   4    16\n#R|  5  CCF   Fall   5    29\n#R|  6  CCF   Fall   6    23\n#R|  7  CCF   Fall   7    20\n#R|  8  CCF   Fall   8    29\n#R|  9  CCF   Fall   9    22\n#R|  10 CCF   Fall  10    12\n#R|  11 CCF   Fall  11     2\n#R|  12 CCF   Fall  12     0\n#R|  13 CCF   Fall  13     0\n#R|  14 CCF   Fall  14     1\n#R|  15 CCF   Fall  15     2\n#R|  16 CCF   Fall  16     0\n#R|  17 CCF   Fall  17     3\n```\n:::\n:::\n\n\nThis data frame is now ready for catch curve analysis.\n\n&nbsp;\n\n# Catch Curve Analysis for Multiple Groups\n### Data Preparation\nA catch curve plots log catch versus age, though in this case, because of the presence of zero catches for some ages, log catch plus 1 was used.^[In [this previous post](../2023-4-1_Milleretal2022_Fig4/) I question whether it is appropriate to add 1 to the catch data for this purpose.] Below a new variable called `Catch1` is added to `CatAge` that contains the catch plus 1 value and the log of this is taken to create `logCatch1`. `Catch1` is needed because `catchCurve()` from `FSA` requires the raw \"catch\" data. `logCatch1` is needed for plotting.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nCatAge <- CatAge |>\n  mutate(Catch1=Catch+1,\n         logCatch1=log(Catch1))\nheadtail(CatAge)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|     Spp Season Age Catch Catch1 logCatch1\n#R|  1  CCF   Fall   1    15     16  2.772589\n#R|  2  CCF   Fall   2    22     23  3.135494\n#R|  3  CCF   Fall   3     3      4  1.386294\n#R|  60 WAE Spring  16     2      3  1.098612\n#R|  61 WAE Spring  17     0      1  0.000000\n#R|  62 WAE Spring  18     2      3  1.098612\n```\n:::\n:::\n\n\nIn general, instantaneous mortality ($Z$) is only estimated from the slope of the \"descending limb\" of the catch curve. The plot below is used to identify the \"descending limb\", though I ultimately used the ages defined by @schalletal_2020:\n\n- *Channel Catfish, Fall* -- ages 5 and older\n- *Channel Catfish, Spring* -- ages 6 and older\n- *Walleye, Fall* -- ages 1 and older\n- *Walleye, Spring* -- ages 2 and older\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(dat=CatAge,mapping=aes(x=Age,y=logCatch1,color=Season)) +\n  geom_point(size=2) +\n  geom_line(alpha=0.1,linewidth=1.5) +\n  facet_grid(rows=vars(Spp),cols=vars(Season)) +\n  theme_bw() + theme(legend.position=\"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/preliminary-catch-curve-plot-1-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nFrom this, a new summary data frame (i.e., `CatAgeReduced`) is created that is the same as `CatAge` but with all ages **not on the descending limb removed**.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nCatAgeReduced <- CatAge |>\n  filter(!(Spp==\"CCF\" & Season==\"Fall\" & Age<5)) |>\n  filter(!(Spp==\"CCF\" & Season==\"Spring\" & Age<6)) |>\n  filter(!(Spp==\"WAE\" & Season==\"Fall\" & Age<1)) |>\n  filter(!(Spp==\"WAE\" & Season==\"Spring\" & Age<2))\n```\n:::\n\n\nThe data were plotted with this new data frame to ensure that the descending limbs were retained as defined in @schalletal_2020.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(dat=CatAgeReduced,mapping=aes(x=Age,y=logCatch1,color=Season)) +\n  geom_point(size=2) +\n  geom_line(alpha=0.1,linewidth=1.5) +\n  facet_grid(rows=vars(Spp),cols=vars(Season)) +\n  theme_bw() + theme(legend.position=\"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/preliminary-catch-curve-plot-2-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nFinally, the overall number of fish for each species and season was computed to compare to results in @schalletal_2020. The number of Channel Catfish retained here was the same for Fall, but one fewer for Spring than in @schalletal_2020. The number of Walleye retained here was one more for Fall and eight more for Spring than in @schalletal_2020. Thus, my mortality calculations in the next section will likely differ slightly from those published in @schalletal_2020.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nCatAgeReduced |>\n  group_by(Spp,Season) |>\n  summarize(n=sum(Catch)) |>\n  ungroup() |>\n  mutate(Schall_n=c(143,423,1217,293))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  # A tibble: 4 × 4\n#R|    Spp   Season     n Schall_n\n#R|    <chr> <chr>  <int>    <dbl>\n#R|  1 CCF   Fall     143      143\n#R|  2 CCF   Spring   422      423\n#R|  3 WAE   Fall    1218     1217\n#R|  4 WAE   Spring   301      293\n```\n:::\n:::\n\n\n### Catch Curve Results\nThe catch curve calculations for one data frame can be performed efficiently with `catchCurve()` from `FSA`. Thus, to use this function for multiple groups of data, the reduced catch-at-age data frame must be `split()` into a list of separate data frames by `Spp` and `Season`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nCatAgeRedSplit <- CatAgeReduced |>\n  split(~Spp+Season)\n```\n:::\n\n\nA helper function was then created that performs the catch curve analysis with `catchCurve()` and extracts the instantaneous and total ($A$) mortality rate estimates, along with their 95% confidence intervals. This function takes the data frame (with at least the catch and age data) as its first argument and a formula of the form `cvar~avar`. Additional named arguments to `catchCurve()`, for example `weighted=TRUE`, can also be included.^[See `?catchCurve` for more information on `catchCurve()`.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Performs catch curve analysis, extracts A & Z estimates and CIs\n##   data: The data frame with, at least, the age & catch variables\n##   formula: A formula of the form `cvar~avar` where cvar is the catch variable\n##            in data and avar is the age variable in data\n##   ...: Additional arguments for FSA::catchCurve()\n## Returns a named vector with the A & Z estimates and CIs\n\ngetCCresults <- function(data,formula,...) {\n  tmp <- FSA::catchCurve(formula,data,...)\n  res <- c(coef(tmp),confint(tmp,parm=\"Z\"),confint(tmp,parm=\"A\"))\n  names(res) <- c(\"Z\",\"A\",\"Z.LCI\",\"Z.UCI\",\"A.LCI\",\"A.UCI\")\n  res[c(1,3,4,2,5,6)]\n}\n```\n:::\n\n\nAs an example, this function is used below to fit a weighted catch curve to Channel Catfish captured in the Spring. Note the use of `Catch1`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngetCCresults(CatAgeRedSplit$CCF.Spring,formula=Catch1~Age,weighted=TRUE)  ## example\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|           Z      Z.LCI      Z.UCI          A      A.LCI      A.UCI \n#R|   0.3466275  0.1303087  0.5629463 29.2931353 12.2175614 43.0471425\n```\n:::\n:::\n\n\nSimilar to before, `getCCresults()` is applied to each data frame in `CatAgeRedSplit` with `map_df()` to return a data frame of catch curve analysis results by group. `.id` is used here in `map_df()` to create a variable in the returned data frame that contains the names of \"items\" from `CatAgeRedSplit`. This is required because `getCCresults()` does not return any identifier for which group the result is for.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nccresults <- CatAgeRedSplit |>\n  map_df(getCCresults,formula=Catch1~Age,weighted=TRUE,.id=\"Group\")\nccresults\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  # A tibble: 4 × 7\n#R|    Group          Z  Z.LCI Z.UCI     A A.LCI A.UCI\n#R|    <chr>      <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl>\n#R|  1 CCF.Fall   0.359 0.221  0.496  30.2 19.9   39.1\n#R|  2 WAE.Fall   0.741 0.509  0.973  52.3 39.9   62.2\n#R|  3 CCF.Spring 0.347 0.130  0.563  29.3 12.2   43.0\n#R|  4 WAE.Spring 0.229 0.0906 0.367  20.5  8.67  30.7\n```\n:::\n:::\n\n\nThe point and interval estimates for $A$ are reasonably close to those published in @schalletal_2020 given the inherent randomization in applying the ALK and the minor differences in sample sizes here versus what they reported.\n\nWhile it is not needed in this post, it will be common to need to \"split\" the `Group` variable in `ccresults` back into its constituent parts (i.e., `Spp` and `Season`). As the constituent parts in `Group` are consistently separated with a `.`, this can be easily accomplished with `separate_wider_delim()` from `tidyr` as shown below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nccresults <- ccresults |>\n  tidyr::separate_wider_delim(Group,\".\",names=c(\"Spp\",\"Season\"))\nccresults\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  # A tibble: 4 × 8\n#R|    Spp   Season     Z  Z.LCI Z.UCI     A A.LCI A.UCI\n#R|    <chr> <chr>  <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl>\n#R|  1 CCF   Fall   0.359 0.221  0.496  30.2 19.9   39.1\n#R|  2 WAE   Fall   0.741 0.509  0.973  52.3 39.9   62.2\n#R|  3 CCF   Spring 0.347 0.130  0.563  29.3 12.2   43.0\n#R|  4 WAE   Spring 0.229 0.0906 0.367  20.5  8.67  30.7\n```\n:::\n:::\n\n\n### Catch Curve Figure\n@schalletal_2020 displayed their catch curve results in their [Figure 3](https://meridian.allenpress.com/view-large/figure/13413355/i1944-687X-12-1-223-f03.tif). The biggest challenge to recreating this figure is that their regression lines are from the **weighted** regression on the descending limb. The weights used are stored in the result from `catchCurve()`, but again this functions needs to be applied on a *per-group* basis. As such, a helper function was created below that performs the catch curve analysis as above, but instead of extracting results it extracts the weights used, appends them to the data frame given to the function, and returns the modified data frame. Thus, this function serves to append the weights used to the original data used.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Performs catch curve analysis and adds estimated weights to data\n##   data: The data frame with, at least, the age & catch variables\n##   formula: A formula of the form `cvar~avar` where cvar is the catch variable\n##            in data and avar is the age variable in data\n##   ...: Additional arguments for FSA::catchCurve()\n## Returns the data data frame with the catch curve weights in wts variable\n\naddCCweights <- function(data,formula,...) {\n  tmp <- FSA::catchCurve(formula,data,...)\n  data <- data |> dplyr::mutate(wts=tmp$w)\n  data\n}\n```\n:::\n\n\nThis function is then applied to each data frame in `CatAgeRedSplit` with `map_df()` to produce a modified data frame with the weights used.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nCatAgeRedWts<- CatAgeRedSplit |>\n  map_df(addCCweights,formula=Catch1~Age,weighted=TRUE)\nheadtail(CatAgeRedWts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|     Spp Season Age Catch Catch1 logCatch1       wts\n#R|  1  CCF   Fall   5    29     30  3.401197 3.5075254\n#R|  2  CCF   Fall   6    23     24  3.178054 3.2178363\n#R|  3  CCF   Fall   7    20     21  3.044522 2.9281472\n#R|  51 WAE Spring  16     2      3  1.098612 0.6867394\n#R|  52 WAE Spring  17     0      1  0.000000 0.4800235\n#R|  53 WAE Spring  18     2      3  1.098612 0.2733075\n```\n:::\n:::\n\n\nThe main part of reproducing Figure 3 consists of creating three \"layers\" of data:\n\n- Plot `logCatch1` versus `Age` from `CatAge` with an open circle (i.e., `pch=21`) with different outline colors based on `Season`. This will produce an open circle for the log catch at all ages across the range of observed ages.\n- Over plot `logCatch` versus `Age` from `CatAgeRedWts` with a circle (i.e., `pch=21`) with different outline **and** fill colors based on `Season`. This will \"fill\" the open circles for ages on the descending limb of the catch curve.\n- Over plot the weighted regression line with colors based on `Season` and using `weight=`s given in `wts`, but which will be separated by season.^[This use of the `weight=` `aes()`thetic was described in [this post](../2023-4-1_Milleretal2022_Fig4/#recreating-figure-4).]\n- Create separate facets by `Spp`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(dat=CatAge,mapping=aes(x=Age,y=logCatch1,color=Season),\n             pch=21,size=2) +\n  geom_point(dat=CatAgeRedWts,mapping=aes(x=Age,y=logCatch1,color=Season,fill=Season),\n             pch=21,size=2) +\n  geom_smooth(dat=CatAgeRedWts,mapping=aes(x=Age,y=logCatch1,\n                                           color=Season,fill=Season,weight=wts),\n              method=lm) +\n  scale_x_continuous(name=\"Age (yrs)\",expand=expansion(mult=0.02)) +\n  scale_y_continuous(name=\"log (Catch+1)\",expand=expansion(mult=0.02)) +\n  scale_color_manual(values=c(\"Fall\"=\"black\",\"Spring\"=\"gray60\"),\n                     aesthetics=c(\"color\",\"fill\")) +\n  facet_wrap(vars(Spp),labeller=labeller(Spp=c(\"CCF\"=\"Channel Catfish\",\n                                               \"WAE\"=\"Walleye\"))) +\n  theme_bw() +\n  theme(panel.grid.major=element_blank(),\n        legend.position=c(1,1),\n        legend.justification=c(1.1,1.1),\n        legend.title=element_blank(),\n        legend.background=element_blank(),\n        strip.text=element_text(face=\"bold\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/schall-figure-3-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n&nbsp;\n\n\n::: {.cell layout-align=\"center\"}\n\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}