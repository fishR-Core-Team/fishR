{
  "hash": "2f4a49244d719dbcb3f166d1397c7471",
  "result": {
    "markdown": "---\ntitle: Ulaski et al. (2022) Growth-Maturity Figure\ndescription: Using ggplot2 to recreate the growth and maturity figure in Ulaski et al. (2022).\nauthor: Derek H. Ogle\ndate: 2/16/2023\nimage: preview.png\ncategories:\n  - Growth\n  - Maturity\n  - Data Wrangling\n  - ggplot2\n  - functions\n  - color\n---\n\n\n# Introduction\n\n@ulaskietal_2022 modeled the White Sturgeon (*Acipenser transmontanus*) population in the Sacramento-San Joaquin River Basin to suggest management goals for the population. Their [Figure 1](https://meridian.allenpress.com/view-large/figure/15050079/i1944-687X-13-2-334-f01.tif) showed a modeled von Bertalanffy growth function with shading below the curve that indicated the probability of being mature for each modeled age. I had not seen a plot like this before and set out to recreate it with `ggplot2`.\n\nThis exercise turned out to be more challenging than I thought and I ultimately reached out to Marta Ulaski, the lead author on the paper, to see if their solution was different or \"easier\" than mine. It was different but I learned something with both methods; thus, I will present both here.^[I modified the specifics but kept the overall concept of Ulaski's approach.]\n\n&nbsp;\n\n# Getting Setup\nThe following packages are loaded for use below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)  # for dplyr, ggplot2 packages\n```\n:::\n\n\nThe `ggplot2` theme was set to `theme_bw()` but with a larger base font size and gridlines removed.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntheme_set(\n  theme_bw(base_size=14) +\n  theme(panel.grid=element_blank())\n)\n```\n:::\n\n\n&nbsp;\n\n### Growth Function\nThe three parameters ($L_{\\infty}$, $K$, and $t_{0}$) of a \"typical\" von Bertalanffy growth function (VBGF) provided in the caption to Figure 1 of @ulaskietal_2022 were entered into the `vbpar` named vector.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvbpar <- c(\"Linf\"=380,\"K\"=0.027,\"to\"=-2.36)\n```\n:::\n\n\n`vbFuns()` from `FSA` was used to create a function that returns the mean length-at-age given a set of ages and \"typical\" VBGF parameters.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvb <- FSA::vbFuns('Typical')\nvb\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  function (t, Linf, K = NULL, t0 = NULL) \n#R|  {\n#R|      if (length(Linf) == 3) {\n#R|          K <- Linf[[2]]\n#R|          t0 <- Linf[[3]]\n#R|          Linf <- Linf[[1]]\n#R|      }\n#R|      Linf * (1 - exp(-K * (t - t0)))\n#R|  }\n#R|  <bytecode: 0x000002744f2c7608>\n#R|  <environment: 0x000002744f244e70>\n```\n:::\n:::\n\n\nWhile this function appears overly complicated, an advantage of this function is that all three parameters of the typical VBGF can be given to the `Linf=` argument.\n\nBelow is an illustrative example for computing the mean length-at-age given the parameters in `vbpar` for ages 10 and 15.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvb(c(10,15),Linf=vbpar)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  [1] 107.8234 142.1949\n```\n:::\n:::\n\n\n`vb()` will be used in both approaches to making Figure 1 below.\n\n&nbsp;\n\n### Maturity Data\n@ulaskietal_2022 provided probabilities of being mature by age in their [Table 1](https://meridian.allenpress.com/view-large/figure/15050076/i1944-687X-13-2-334-t01.tif). Here I entered those data directly into a data frame, though I multiplied the probabilities by 100 as that is how they are presented in Figure 1. I also added a much older age of 50 to illustrate how this process could be extended to older ages than what was shown in their Figure 1.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat <- data.frame(age=c(0,10:20,50),\n                    prmat=c(0,0.025,0.086,0.143,0.291,0.543,\n                            0.622,0.788,0.849,0.942,0.966,1,1)*100)\ndfmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|     age prmat\n#R|  1    0   0.0\n#R|  2   10   2.5\n#R|  3   11   8.6\n#R|  4   12  14.3\n#R|  5   13  29.1\n#R|  6   14  54.3\n#R|  7   15  62.2\n#R|  8   16  78.8\n#R|  9   17  84.9\n#R|  10  18  94.2\n#R|  11  19  96.6\n#R|  12  20 100.0\n#R|  13  50 100.0\n```\n:::\n:::\n\n\nThe probabilities presented in Figure 1 have been binned into categories. The first category is simply 0% (none mature), but each category after that has a width of 10%. Thus, the next two categories would be from 0.1 to 10%, and 10.1 to 20%. @ulaskietal_2022 chose to label these two categories as \"0-10%\" and \"10-20%\", respectively.\n\nThese categories may be created with `cut()`, which takes the data to categorize as its first argument, the values at which to \"cut\" the categories in `breaks=`, and labels for the categories in `labels=`. It is important to note that `cut()` makes categories right-inclusive by default. Thus, if the breaks are `c(0,10,20)` then the first category would be from 0 to 10, with 10 being inclusive. Thus, a value of 9 or 10 would be included in this category, but 0 would not. Thus, to have a category for just the 0 values, the breaks must start at some negative number (in this case, negative infinity was used).^[`seq(0,100,10)` creates a sequence from 0 to 100 in steps of 10.] The results of `cut()` were added to the `prcuts` variable in `dfmat`.^[Because using `mutate()`.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat <- dfmat |>\n  mutate(prcuts=cut(prmat,\n                    breaks=c(-Inf,seq(0,100,10)),\n                    labels=c(\"0%\",\"0-10%\",\"10-20%\",\"20-30%\",\"30-40%\",\"40-50%\",\n                             \"50-60%\",\"60-70%\",\"70-80%\",\"80-90%\",\"90-100%\")))\ndfmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|     age prmat  prcuts\n#R|  1    0   0.0      0%\n#R|  2   10   2.5   0-10%\n#R|  3   11   8.6   0-10%\n#R|  4   12  14.3  10-20%\n#R|  5   13  29.1  20-30%\n#R|  6   14  54.3  50-60%\n#R|  7   15  62.2  60-70%\n#R|  8   16  78.8  70-80%\n#R|  9   17  84.9  80-90%\n#R|  10  18  94.2 90-100%\n#R|  11  19  96.6 90-100%\n#R|  12  20 100.0 90-100%\n#R|  13  50 100.0 90-100%\n```\n:::\n:::\n\n\n`dfmat` will be used in both approaches to making Figure 1 below.\n\n&nbsp;\n\n### Define Repetitive Values\nFor simplicity, some values that will be used in both approaches were assigned to objects that can be reused.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# x-axis (age) title, limits, labels\nagettl <- \"Age (yrs)\"\nagelmts <- c(0,20)\nagelbls <- 0:20\n# y-axis (length) title, limits, labels\nlenttl <- \"Length (cm)\"\nlenlmts <- c(0,200)\nlenlbls <- seq(0,200,50)\n# fill color (probability mature) title\nprobttl <- \"Probability\"\n```\n:::\n\n\n&nbsp;\n\n# My Recreation of Figure 1\n### Plotting the von B function\nThe typical VBGF can be plotted over the range of ages in a data frame with `stat_function()`.^[Make sure to map the age variable to the `x` aesthetic.] The function to be evaluated (i.e., `vb()`) is given in `fun=` and any arguments that it requires are given in a list to `args=`.^[Here we can set `vbpar` to just `Linf` given that all parameters can be given to this one argument as shown above.] The smoothness of the curve can be controlled with `n=`, which is the number of ages over the range of ages for which the function will be evaluated.^[`n=` defaults to 101, which appeared adequate for these data, though I increased it here to demonstrate its use.] Finally, I increased the line width slightly.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=dfmat,mapping=aes(x=age)) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  stat_function(fun=vb,args=list(Linf=vbpar),\n                n=202,linewidth=0.75)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-vonB-line-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nAs seen above, `stat_function()` defaults to drawing a line of the function (i.e., it uses `geom_line()`). However, other geoms can be used; e.g., `geom=\"area\"`.^[I used `fill=` here to show the effect, but this also required setting `color=` because the color for the line took on the fill color.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=data.frame(age=c(0,20)),mapping=aes(x=age)) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  stat_function(fun=vb,args=list(Linf=vbpar),\n                n=202,linewidth=0.75,\n                geom=\"area\",fill=\"salmon\",color=\"black\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-vonB-area-1.png){fig-align='center' width=576}\n:::\n:::\n\n\n&nbsp;\n\n### Adding the Maturity Scale\nMy solutions to recreating Figure 1 of @ulaskietal_2022 generally followed the StackOverflow answer at the bottom of [this question](https://stackoverflow.com/questions/33244629/filling-under-the-a-curve-with-ggplot-graphs). This process uses `after_stat()` and `after_scale()`, which were introduced to `ggplot2` in v3.3.0.^[See their introduction [here](https://www.tidyverse.org/blog/2020/03/ggplot2-3-3-0/#more-control-over-aesthetic-evaluation).] I don't yet fully understand these two functions, but will try to explain what I think they are doing.\n\nAs illustrated above, `stat_function()` produces a smooth curve by creating `n=` values of `x` over the range of the variable mapped to the `x=` aesthetic. One part of the \"trick\" to this solution is to first realize that these \"age\" values created by `stat_function()` are not integers and, thus, they need to be \"cut\" into integer age categories. The second part of the \"trick\" to this solution is that the probability of maturity category labels should be used for the \"cuts\" of age rather than labels of age. For example, an age of 13.5 created by `stat_function()` should be categorized as an age of 13 but labeled with \"20-30%\".^[Examine `dfmat` to see why.] This cutting of the age values comes after they have been created by `stat_function()` in the `x=` aesthetic and are thus accessed by `after_stat(x)` which I pipe into `cut()` and set equal to the `fill=` aesthetic in `stat_function()`.\n\nThe third part of the \"trick\" to this solution is to realize that the different colored areas can only be plotted if the `group=` aesthetic is set to the same categories used in the `fill=` aesthetic. As the `fill=` aesthetic was just created and is defined in a `scale` (see `scale_fill_viridis_d()` below), the `group=` aesthetic must be defined with `after_scale(fill)`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=dfmat,mapping=aes(x=age)) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  stat_function(mapping=aes(fill=after_stat(x) |>\n                              cut(breaks=!!dfmat$age,\n                                  labels=!!dfmat$prcuts[-nrow(dfmat)],\n                                  include.lowest=TRUE),\n                            group=after_scale(fill)),\n                fun=vb,args=list(Linf=vbpar),n=202,\n                geom=\"area\",color=\"black\",linewidth=0.75)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/figure-1-DHO-1-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThis, obviously, is not ideal ... largely due to the long name for the legend. However, it is also not the colors used in Figure 1 of @ulaskietal_2022. A custom viridis-based color scheme was used in @ulaskietal_2022,^[I would not have \"discovered\" this color scheme on my own. This came from seeing Ulaski's original code.] which can be used with `scale_fill_viridis_d()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=dfmat,mapping=aes(x=age)) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  stat_function(mapping=aes(fill=after_stat(x) |>\n                              cut(breaks=!!dfmat$age,\n                                  labels=!!dfmat$prcuts[-nrow(dfmat)],\n                                  include.lowest=TRUE),\n                            group=after_scale(fill)),\n                fun=vb,args=list(Linf=vbpar),n=202,\n                geom=\"area\",color=\"black\",linewidth=0.75) +\n  scale_fill_viridis_d(name=probttl,begin=0.85,end=0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/figure-1-DHO-2-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nFinally, there are two things with this plot that I don't like. First, the black line for the growth function appears broken at the color breaks. Second, the linewidth around the colors in the legend is too thick. To correct these issues, I removed `linewidth=` and `color=` from `stat_function()` and then added a second `stat_function()` that plots just the growth function as a line.^[See the first use of `stat_function()` further above for how this was done.] This second use of `stat_function()` lays the function line on top of the function \"area.\"\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=dfmat,mapping=aes(x=age)) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  stat_function(mapping=aes(fill=after_stat(x) |>\n                              cut(breaks=!!dfmat$age,\n                                  labels=!!dfmat$prcuts[-nrow(dfmat)],\n                                  include.lowest=TRUE),\n                            group=after_scale(fill)),\n                fun=vb,args=list(Linf=vbpar),n=202,\n                geom=\"area\") +\n  scale_fill_viridis_d(name=probttl,begin=0.85,end=0) +\n  stat_function(fun=vb,args=list(Linf=vbpar),n=202,\n                color=\"black\",linewidth=0.75)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/figure-1-DHO-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n:::{.callout-note appearance=\"simple\"}\n### Future Updates?\nI may update this post as I learn more about `after_stat()` and `after_scale()`.\n:::\n\n&nbsp;\n\n# Author's Creation of Figure 1\n\n:::{.callout-important appearance=\"simple\"}\n## Acknowledgment\nThe solution in this section follows the concept of the code provided to me by Marta Ulaski, the lead author on the original paper. I have modified the specific code to better fit the rest of the post. I thank Marta for generously providing her source code and allowing me to modify it for presentation here.\n:::\n\n&nbsp;\n\n### Making the Data Frame\nUlaski's solution to making this figure is much simpler to explain (Thank you!) but relies on explicitly creating a data frame that is largely what `stat_function()` did behind-the-scenes. Specifically, Ulaski created a data frame that repeated the probability of being mature for all ages in increments of 0.1. So, for example, this data frame contained an age of 12.3 with the probability of being mature being the same as that for age 12. To generalize this solution I set out to see if I could create this data frame from the simple `dfmat` created above.^[Ulaski had manually created a CSV with these repeated data, which were read in to a data frame.]\n\nRecall what the original `dfmat` looked like ... ages and probabilities of maturity from Table 1 in the published paper, and categories of probability mature created with `cut()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|     age prmat  prcuts\n#R|  1    0   0.0      0%\n#R|  2   10   2.5   0-10%\n#R|  3   11   8.6   0-10%\n#R|  4   12  14.3  10-20%\n#R|  5   13  29.1  20-30%\n#R|  6   14  54.3  50-60%\n#R|  7   15  62.2  60-70%\n#R|  8   16  78.8  70-80%\n#R|  9   17  84.9  80-90%\n#R|  10  18  94.2 90-100%\n#R|  11  19  96.6 90-100%\n#R|  12  20 100.0 90-100%\n#R|  13  50 100.0 90-100%\n```\n:::\n:::\n\n\nA new data frame is created that has fractional ages that begin at the minimum age in `dfmat`, end at the maximum age in `dfmat`, and uses a constant increment (0.1 in this example). `lencat()` from `FSA` is then used to create categories of ages that match the ages in `dfmat`. `lencat()` returns a factor variable by default but `as.fact=FALSE` causes it to return a number to match the `age` variable in `dfmat`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat2 <- data.frame(agef=seq(min(dfmat$age),max(dfmat$age),0.1)) |>\n  mutate(age=FSA::lencat(agef,breaks=dfmat$age,as.fact=FALSE))\nFSA::headtail(dfmat2,n=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|      agef age\n#R|  1    0.0   0\n#R|  2    0.1   0\n#R|  3    0.2   0\n#R|  4    0.3   0\n#R|  5    0.4   0\n#R|  497 49.6  20\n#R|  498 49.7  20\n#R|  499 49.8  20\n#R|  500 49.9  20\n#R|  501 50.0  50\n```\n:::\n:::\n\n\nThe probability mature values and categories are added to this data frame with `left_join()` using the common `age` variable in `dfmat` and `dfmat2`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat2 <- dfmat2 |>\n  left_join(dfmat,by=\"age\")\nFSA::headtail(dfmat2,n=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|      agef age prmat  prcuts\n#R|  1    0.0   0     0      0%\n#R|  2    0.1   0     0      0%\n#R|  3    0.2   0     0      0%\n#R|  4    0.3   0     0      0%\n#R|  5    0.4   0     0      0%\n#R|  497 49.6  20   100 90-100%\n#R|  498 49.7  20   100 90-100%\n#R|  499 49.8  20   100 90-100%\n#R|  500 49.9  20   100 90-100%\n#R|  501 50.0  50   100 90-100%\n```\n:::\n:::\n\n\nFinally, the predicted mean lengths are added using `vb()` as before.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat2 <- dfmat2 |>\n  mutate(len=vb(agef,Linf=vbpar))\nFSA::headtail(dfmat2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|      agef age prmat  prcuts       len\n#R|  1    0.0   0     0      0%  23.45828\n#R|  2    0.1   0     0      0%  24.41965\n#R|  3    0.2   0     0      0%  25.37842\n#R|  499 49.8  20   100 90-100% 287.06956\n#R|  500 49.9  20   100 90-100% 287.32013\n#R|  501 50.0  50   100 90-100% 287.57003\n```\n:::\n:::\n\n\nThese steps can be combined into one tight set of code as shown below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat2 <- data.frame(agef=seq(min(dfmat$age),max(dfmat$age),0.1)) |>\n  mutate(age=FSA::lencat(agef,breaks=dfmat$age,as.fact=FALSE)) |>\n  left_join(dfmat,by=\"age\") |>\n  mutate(len=vb(agef,Linf=vbpar))\n```\n:::\n\n\n&nbsp;\n\n### Making the Figure\nFigure 1 is then created by mapping the fractional ages (i.e., `agef`) to `x=` and the lengths to `y`, mapping the probability cuts to `fill=` in `geom_ares()`, and including `geom_line()` (with a slightly larger line width).^[This will produce a warning because the data frame extends to age 50 but the figure is limited to age 20.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=dfmat2,mapping=aes(x=agef,y=len)) + \n  geom_area(mapping=aes(fill=prcuts)) + \n  geom_line(linewidth=0.75) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  scale_fill_viridis_d(name=\"Probability\",begin=0.85,end=0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/figure-1-MU-1.png){fig-align='center' width=672}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n&nbsp;\n\n# Further Thoughts\nThere are a few things that I would like to see different in this figure. First, the \"white\" lines between the colors are too prominent. The size of these lines are a function of the number of \"fractional\" ages used to produce the plot. Thus, to make these \"lines\" thinner one could increase `n=` in my solution or decrease `by=` in the author's solution.\n\nSecond, it bothers me that the colors for the probabilities seem equally spaced even though two categories are not represented in the data (e.g., 30-40% and 40-50%). In my mind, there should be a \"jump\" in colors at the ages where the probability jumps from 20-30% to 50-60% (i.e., between age-13 and age-14).^[This will be a common issue with maturity data as the probability of maturity often increases dramatically over a short range of lengths and, thus, one or very few ages.] I could not address this issue with my solution, but including `drop=FALSE` in `scale_fill_viridis_d()` fixed this in the author's solution.\n\nThird, the \"line\" does not look like a typical VBGF to me as these sturgeon are long-lived and grow so slowly that very little curvature and no asymptote is evident. In some situations is may be useful to extend the x-axis to older ages to better \"see\" the typical asymptotic growth of the VBGF.^[This is not that useful here given the shape of the VBGF for this species.]\n\nFinally, the authors started their plot at age-1. I am not sure why they did this, but that can be accomplished by filtering the data to only age-1 and older.\n\nAll of these changes (with `by=0.05` and extending the ages to 30) were made below using the author's solution.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nagelmts <- c(0,30)                               # changed max\nagelbls <- seq(0,30,2)                           # changed max, made sequence by 2\nlenlmts <- c(0,250)                              # changed max\nlenlbls <- seq(0,250,50)                         # changed max\n\nby <- 0.05                                       # made smaller\n\ndfmat3 <- data.frame(agef=seq(min(dfmat$age),max(dfmat$age),by)) |>\n  mutate(age=FSA::lencat(agef,breaks=dfmat$age,as.fact=FALSE)) |>\n  left_join(dfmat,by=\"age\") |>\n  mutate(len=vb(agef,Linf=vbpar)) |>\n  filter(agef>=1)                                # filtered out <age-1\n\nggplot(data=dfmat3,mapping=aes(x=agef,y=len)) +  # used new dfmat3\n  geom_area(mapping=aes(fill=prcuts)) + \n  geom_line(linewidth=0.75) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  scale_fill_viridis_d(name=\"Probability\",begin=0.85,end=0,drop=FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/figure-1-MU2-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n&nbsp;\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}