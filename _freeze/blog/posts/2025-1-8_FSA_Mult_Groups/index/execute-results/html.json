{
  "hash": "f31ae421abfe2b7fb14de130f476fc09",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: FSA Analyses for Multiple Groups\ndescription: Demonstrate new (or improved) functionality in the FSA package for efficiently performing some analyses across multiple groups.\nauthor: Derek H. Ogle\ndate: 1/8/2025\nimage: preview.png\ncategories:\n  - Abundance\n  - Catch Curve\n  - Depletion\n  - Removal\n  - group_by\n  - purrr\n---\n\n\n\n# Introduction\nA year or so ago a user of `FSA` asked me if there was a way to use `group_by()` from `dplyr()` with `removal()` from `FSA` to efficiently estimate fish abundance from removal data for multiple groups. There was not, as far as either of us could tell. My naive impression was that I would need a new version of `removal()` that used formula notation with a `data=` argument. So, I modified removal to use a formula and `data=`.\n\nHowever, this was not an adequate solution because I did not want to change the contents of the list that was returned from `removal()`. Furthermore required both `coef()` and `confint()` (S3 extractor functions for `removal()`) to extract the results the user wanted from this list. My solution for this was to modify `confint()` with `incl.est=` that would append the confidence intervals to the point estimate (extracted with `coef()`) when set to `TRUE`.\n\nHowever, `confint()` returned a matrix which I found difficult to work with within any of the `dplyr` functions. Thus, I further modified `confint()`^[And `coef()` and `summary()` while I was at it.] with `as.df=` to return a data.frame rather than a matrix when set to `TRUE`. Both `incl.est=` and `as.df=` default to `FALSE` so that the original functionality is maintained (by default).^[Trying not to break user's legacy code.] Thus, to get the new functionality both `incl.est=` and `as.df=` must be explicitly set to `TRUE` by the user.\n\nThese changes seemed to meet the user's request. Thus, I made similar changes to `depletion()`, `catchCurve()`, and `chapmanRobson()`. In this post, I demonstrate how these new functions work vis-a-vis helper functions from `dplyr` (and, briefly, `purrr`).\n\nThe following packages are loaded for use below. Note that the modified `removal()`, `depletion()`, `catchCurve()`, and `chapmanRobson()` functionality **requires FSA v0.9.6 or higher**.^[This version is at CRAN being processed when this post was written.]\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(FSA)       # for depletion(), removal(), catchCurve(), chapmanRobson(), headtail()\nlibrary(tidyverse) # for dplyr, tidyr\n```\n:::\n\n\n\n\n# Abundance\n## Removal Estimates\nThe new functionality of `removal()` is demonstrated with the user's (partial) data, entered manually below.^[I usually enter data into a CSV file external to R. This is for demonstration only.]\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nd <- data.frame(lake=factor(rep(c(\"Ash Tree\",\"Bark\",\"Clay\"),each=5)),\n                year=factor(rep(c(\"2010\",\"2011\",\"2010\",\"2011\",\"2010\",\"2011\"),\n                                times=c(2,3,3,2,2,3))),\n                pass=factor(c(1,2,1,2,3,1,2,3,1,2,1,2,1,2,3)),\n                catch=c(57,34,65,34,12,54,26,9,54,27,67,34,68,35,12))\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|         lake year pass catch\n#R|  1  Ash Tree 2010    1    57\n#R|  2  Ash Tree 2010    2    34\n#R|  3  Ash Tree 2011    1    65\n#R|  4  Ash Tree 2011    2    34\n#R|  5  Ash Tree 2011    3    12\n#R|  6      Bark 2010    1    54\n#R|  7      Bark 2010    2    26\n#R|  8      Bark 2010    3     9\n#R|  9      Bark 2011    1    54\n#R|  10     Bark 2011    2    27\n#R|  11     Clay 2010    1    67\n#R|  12     Clay 2010    2    34\n#R|  13     Clay 2011    1    68\n#R|  14     Clay 2011    2    35\n#R|  15     Clay 2011    3    12\n```\n\n\n:::\n:::\n\n\n\nThere are several things to note with these data. First, they are in \"long\" format where each row corresponds to one observation -- in this case the catch of fish on a particular `pass` within a given `year` and `lake`. Second, the user wanted to estimated abundance from catches (i.e., removal) on multiple passes for all possible lake-year combinations; thus, \"group\" is defined by the combination of `lake` and `year`. Third, the number of passes was not consistent, with some year-lake combinations having two and others having three passes. This is not an issue as long as a removal method is used that can handle both numbers of removal. The default Carle-Strub method^[See `method=` argument in `removal()` for other methods.] will be used here, so this will not be an issue. Fourth, it is important when data are in \"long\" format like this that the passes are ordered consecutively from first to last. That is the case here, but if it was not then the data.frame would need to be sorted on `pass` (within `lake` and `year`).\n\n`removal()` from `FSA` is used to compute estimates of initial population abundance (No) and probability of capture (p) by using a formula of the form `~catch` with the data.frame containing the variable in `data=`.^[If the variable is not called `catch` as it is here, then replace with the actual variable name.] The result of this function is assigned to an object which is then given to `confint()` to extract confidence intervals for the parameters. Including `incl.est=TRUE` in `confint()` will include the point estimate in the result. Below is an example of using `depletion()` for just Ash Tree lake in 2010.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntmp <- removal(~catch,data=dplyr::filter(d,lake==\"Ash Tree\",year==\"2010\"))\nconfint(tmp,incl.est=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|             Est    95% LCI     95% UCI\n#R|  No 130.0000000 78.8281665 181.1718335\n#R|  p    0.4482759  0.2107166   0.6858351\n```\n\n\n:::\n:::\n\n\n\nThe object returned by `confint()` is a matrix by default, which generally prints nicely. However, the result may be returned as a data.frame, which as described previously will be needed with the `dplyr` functions used below, by including `as.df=TRUE` in `confint()`.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nconfint(tmp,incl.est=TRUE,as.df=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|     No   No.LCI   No.UCI         p     p.LCI     p.UCI\n#R|  1 130 78.82817 181.1718 0.4482759 0.2107166 0.6858351\n```\n\n\n:::\n:::\n\n\n\n`removal()` can be used to compute parameter estimates for multiple groups by first giving the variable or variables that identify groups to `group_by()` and then giving that to `group_modify()` from `dplyr`. The first argument to `group_modify()`, when piped together with `%>%`, is an expression that begins with `~` followed by a call to `removal()` nested within a call to `confint()`. In the `removal()` call `data=` **must** be set to `.x`. The call to `confint()` should include `incl.est=TRUE` to get the point estimates of the parameters and **must** include `as.df=TRUE` for `group_modify()` to work properly.^[`group_modify()` requires the function defined after the `~` to return a data.frame.] Below I submit the result to `as.data.frame()` simply to remove the grouping structure and tibble class.^[I prefer to work with data.frames rather than tibbles.]\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres <- d %>%\n  dplyr::group_by(lake,year) %>%\n  dplyr::group_modify(~confint(removal(~catch,data=.x),\n                               incl.est=TRUE,as.df=TRUE)) %>%\n  as.data.frame() # removes tibble and grouping structure\n```\n:::\n\n\n\nFor display purposes, the results for the two parameters are rounded to different numbers of `digits`.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres %>% \n  dplyr::mutate(dplyr::across(dplyr::starts_with(\"No\"), \\(x) round(x,digits=0))) %>%\n  dplyr::mutate(dplyr::across(dplyr::starts_with(\"p\"), \\(x) round(x,digits=3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|        lake year  No No.LCI No.UCI     p p.LCI p.UCI\n#R|  1 Ash Tree 2010 130     79    181 0.448 0.211 0.686\n#R|  2 Ash Tree 2011 121    110    132 0.558 0.440 0.676\n#R|  3     Bark 2010  95     87    103 0.589 0.464 0.715\n#R|  4     Bark 2011 103     74    132 0.533 0.314 0.752\n#R|  5     Clay 2010 130     96    164 0.523 0.324 0.723\n#R|  6     Clay 2011 125    114    136 0.564 0.449 0.679\n```\n\n\n:::\n:::\n\n\n\n## Depletion Estimates\nThe `Pathfinder` data^[[See description here](https://fishr-core-team.github.io/FSAdata/reference/Pathfinder.html).] from `FSAdata` contains the catch and effort for three Snapper species (*Pristipomoides zonatus*, *Pristipomoides auricilla*, and *Etelis carbunculUs*) in a depletion experiment around Pathfinder Reef in the Mariana Archipelago. @polovina_1985 used these data to demonstrate the need for a Leslie depletion model with variable recruitment (as was evident for *Pristipomoides auricilla*). Here these data are used to demonstrate how to efficiently compute population (No) and catchability (q)  estimates for each species using `depletion()` from `FSA` with help from `dplyr`.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(Pathfinder,package=\"FSAdata\")\nheadtail(Pathfinder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|       date effort Pzonatus Pauricilla Ecarbunculus\n#R|  1  10-Apr   27.5       98         12           42\n#R|  2  11-Apr   23.7      111         17           22\n#R|  3  12-Apr   21.3       47         12           41\n#R|  11  5-May   20.3       40         29           13\n#R|  12  6-May   22.8       35         35           21\n#R|  13  7-May   24.1       30         27           15\n```\n\n\n:::\n:::\n\n\n\nThe data are provided in \"wide\" format where the catch of each species is presented as a column or variable in `Pathfinder`. The methods used below require data to be in \"long\" format where each row corresponds to one observation -- in this case catch (and effort and other associated date) for one species (on one day). In some cases the data may have been entered in long format, but when it is not it must be converted to long format for the process used below.\n\nThere are several methods for converting from wide to long formats. In my mind, one of the easiest is `pivot_longer()` from `tidyr`.^[Some alternatives are `reshape()` from base R and `melt()` from `reshape2`.] The names of columns that contain the values to be converted from wide to long are given to `cols=`. In this example, that will be the columns containing the catches of the separate species. Because those columns are contiguous in the original data.frame they can be referred to *en masse* by separating the name of the left-most column from the name for the right-most column with a colon. The three catch columns from the original data.frame will be moved to two columns in the resulting data.frame -- one with the catch values and one with the spcies names. A name for the column of names can be given to `names_to=` and a name for the values column can be given to `values_to=`. Thus, `Pathfinder` is converted from wide to long format below.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nPathfinder <- Pathfinder |>\n  tidyr::pivot_longer(cols=Pzonatus:Ecarbunculus,\n                      names_to=\"species\",values_to=\"catch\")\nstr(Pathfinder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|  tibble [39 Ã— 4] (S3: tbl_df/tbl/data.frame)\n#R|   $ date   : Factor w/ 13 levels \"10-Apr\",\"11-Apr\",..: 1 1 1 2 2 2 3 3 3 4 ...\n#R|   $ effort : num [1:39] 27.5 27.5 27.5 23.7 23.7 23.7 21.3 21.3 21.3 29.7 ...\n#R|   $ species: chr [1:39] \"Pzonatus\" \"Pauricilla\" \"Ecarbunculus\" \"Pzonatus\" ...\n#R|   $ catch  : int [1:39] 98 12 42 111 17 22 47 12 41 91 ...\n```\n\n\n:::\n:::\n\n\n\nOnce the data are in long format, `depletion()` can be used within `group_modify()` as shown for `removal()`. However, note that `depletion()` requires a formula of the form `catch~effort` and that groups are defined by only the single variable `species` here.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres <- Pathfinder %>%\n  dplyr::group_by(species) %>%\n    dplyr::group_modify(~confint(depletion(catch~effort,data=.x),\n                                 incl.est=TRUE,as.df=TRUE)) %>%\n    as.data.frame() # removes tibble and grouping structure\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres %>% \n  dplyr::mutate(dplyr::across(dplyr::starts_with(\"No\"), \\(x) round(x,digits=0))) %>%\n  dplyr::mutate(dplyr::across(dplyr::starts_with(\"p\"), \\(x) round(x,digits=3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|         species   No No_LCI No_UCI            q        q_LCI         q_UCI\n#R|  1 Ecarbunculus  571    224    918  0.002499027  0.000399448  0.0045986060\n#R|  2   Pauricilla -165     34   -363 -0.003134290 -0.005368398 -0.0009001819\n#R|  3     Pzonatus 1062    795   1328  0.003678569  0.002225597  0.0051315404\n```\n\n\n:::\n:::\n\n\n\n# Mortality\n## Catch Curves\nA similar process can be followed with `catchCurve()` to estimate mortality for several groups. However, the \"long\" format data.frame either needs to contain only data for ages on the descending limb for each group or groups that have the same ages on the descending limb. Both instances are illustrated below.\n\n`FHCatfish` from `FSAdata`^[[See description here.](https://fishr-core-team.github.io/FSAdata/reference/FHCatfish.html)] contains numbers of Flathead Catfish (*Pylodictis olivaris*) captured by electrofishing in three rivers -- Coosa River, AL; Ocmulgee River, GA; and Satilla River, GA -- for ages **ONLY** on the descending limb of the catch curve.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(FHCatfish,package=\"FSAdata\")\nheadtail(FHCatfish)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|       river age abundance\n#R|  1    Coosa   2        25\n#R|  2    Coosa   3        24\n#R|  3    Coosa   4        18\n#R|  37 Satilla   6         1\n#R|  38 Satilla   7         1\n#R|  39 Satilla  10         1\n```\n\n\n:::\n:::\n\n\n\nThe process here is essentially the same as it was for `depletion()` except noting that `catchCurve()` uses a formula of the form `catch~age`.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres <- FHCatfish %>%\n  dplyr::group_by(river) %>%\n  dplyr::group_modify(~confint(catchCurve(abundance~age,data=.x),\n                               incl.est=TRUE,as.df=TRUE)) %>%\n  as.data.frame() # removes tibble and grouping structure\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres %>% \n  dplyr::mutate(dplyr::across(dplyr::starts_with(\"Z\"), \\(x) round(x,digits=3))) %>%\n  dplyr::mutate(dplyr::across(dplyr::starts_with(\"A\"), \\(x) round(x,digits=1)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|       river     Z Z_LCI Z_UCI    A A_LCI A_UCI\n#R|  1    Coosa 0.164 0.123 0.205 15.1  11.5  18.5\n#R|  2 Ocmulgee 0.269 0.194 0.344 23.6  17.6  29.1\n#R|  3  Satilla 0.683 0.195 1.171 49.5  17.7  69.0\n```\n\n\n:::\n:::\n\n\n\n`WalleyeKS` from `FSAdata` contains the catch of Walleye at all observed ages in eight reservoirs in Kansas.^[[See description here.](https://fishr-core-team.github.io/FSAdata/reference/WalleyeKS.html)] The descending limb was determined to start at age-2 for fish from each reservoir, even though other ages appear in the data.frame. Thus, `ages2use=` must be used in `catchCurve()` to identify the ages on the descending limb. Here a sequence of ages beginning with 2 and ending with the maximum observed age was used.^[This will result in a sequence of warnings from `catchCurve()` as some of the groups do not have fish of the maximum age.] Otherwise the code below is similar to that above.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(WalleyeKS,package=\"FSAdata\")\nstr(WalleyeKS)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|  'data.frame':\t66 obs. of  3 variables:\n#R|   $ reservoir: Factor w/ 8 levels \"Cedar.Bluff\",..: 1 1 1 1 1 1 1 1 2 2 ...\n#R|   $ age      : int  0 1 2 3 4 5 6 7 0 1 ...\n#R|   $ catch    : int  78 70 104 52 33 13 4 2 131 28 ...\n```\n\n\n:::\n\n```{.r .cell-code}\n( maxage <- max(WalleyeKS$age) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|  [1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nres <- WalleyeKS %>%\n  dplyr::group_by(reservoir) %>%\n  dplyr::group_modify(~confint(catchCurve(catch~age,data=.x,ages2use=2:11),\n                               incl.est=TRUE,as.df=TRUE)) %>%\n  as.data.frame() # removes tibble and grouping structure\n\nres %>% \n  dplyr::mutate(dplyr::across(dplyr::starts_with(\"Z\"), \\(x) round(x,digits=3))) %>%\n  dplyr::mutate(dplyr::across(dplyr::starts_with(\"A\"), \\(x) round(x,digits=1)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|      reservoir     Z Z_LCI Z_UCI    A A_LCI A_UCI\n#R|  1 Cedar.Bluff 0.811 0.664 0.958 55.6  48.5  61.6\n#R|  2      Cheney 0.551 0.174 0.928 42.4  16.0  60.5\n#R|  3  Glen.Elder 0.855 0.516 1.194 57.5  40.3  69.7\n#R|  4      Kirwin 0.941 0.493 1.388 61.0  38.9  75.1\n#R|  5    Lovewell 0.544 0.279 0.809 41.9  24.3  55.5\n#R|  6      Marion 0.613 0.346 0.879 45.8  29.3  58.5\n#R|  7     Webster 0.567 0.132 1.002 43.3  12.4  63.3\n#R|  8      Wilson 0.719 0.555 0.884 51.3  42.6  58.7\n```\n\n\n:::\n:::\n\n\n\n## Chapman-Robson\nThe process for the Chapman-Robson method is the same as that for the catch-curve except that `chapmanRobson()` is used instead of `catchCurve()`.^[Also note that S is returned rather than A.]\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres <- WalleyeKS %>%\n  dplyr::group_by(reservoir) %>%\n  dplyr::group_modify(~confint(chapmanRobson(catch~age,data=.x,ages2use=2:11),\n                               incl.est=TRUE,as.df=TRUE)) %>%\n  as.data.frame() # removes tibble and grouping structure\n\nres %>% \n  dplyr::mutate(dplyr::across(dplyr::starts_with(\"S\"), \\(x) round(x,digits=1))) %>%\n  dplyr::mutate(dplyr::across(dplyr::starts_with(\"Z\"), \\(x) round(x,digits=3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|      reservoir    S S_LCI S_UCI     Z Z_LCI Z_UCI\n#R|  1 Cedar.Bluff 46.9  42.0  51.9 0.754 0.662 0.846\n#R|  2      Cheney 53.5  48.1  58.9 0.623 0.162 1.085\n#R|  3  Glen.Elder 45.1  42.7  47.4 0.796 0.665 0.927\n#R|  4      Kirwin 39.0  31.1  47.0 0.930 0.732 1.129\n#R|  5    Lovewell 59.5  56.6  62.3 0.519 0.215 0.823\n#R|  6      Marion 59.2  56.5  61.9 0.524 0.308 0.739\n#R|  7     Webster 57.7  50.8  64.7 0.546 0.361 0.731\n#R|  8      Wilson 47.1  42.7  51.5 0.751 0.583 0.919\n```\n\n\n:::\n:::\n\n\n\n# Example Using purrr\nIt is also possible to use `purrr` functions with these new `FSA` functions, though I am not sure that it is more convenient. Here `purrr` is used to repeat the Chapman-Robson results from above.\n\nFirst, a new function must be declared that combines the `confint()` and `chapmanRobson()` functions, making sure to include `incl.est=TRUE` and `as.df=TRUE`. Note that `x=x` is used because the argument o `chapmanRobson()` that takes the formulas is `x=`.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nchapmanRobson2 <- function(x,...) {confint(chapmanRobson(x=x,...),\n                                           incl.est=TRUE,as.df=TRUE)}\n```\n:::\n\n\n\nThe long form data.frame is then split by groups into a list with a data.frame for each group. Here `WalleyeKS` is split on `reservoir` with `split()`, but `split()` requires the \"splitting variable\" to be a factor so `reservoir` was coerced to a factor below.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nWalleyeKS_list <- split(WalleyeKS,as.factor(WalleyeKS$reservoir))\n```\n:::\n\n\n\n`map_df()` from `purrr` takes the list as the first argument and the function to apply to each item in the list as the second argument (i.e., our new `chapmanRobson2()`) and returns a data.frame. The `x=` is the formula of form `catch~age` and the `ages2use=` to be given to `chapmanRobson`. The `.id=` provides a name for the group variable in the data.frame returned by `map_df()`.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres <- purrr::map_df(WalleyeKS_list,chapmanRobson2,\n                     x=catch~age,\n                     ages2use=2:11,\n                     .id=\"reservoir\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres %>% \n  dplyr::mutate(dplyr::across(dplyr::starts_with(\"S\"), \\(x) round(x,digits=1))) %>%\n  dplyr::mutate(dplyr::across(dplyr::starts_with(\"Z\"), \\(x) round(x,digits=3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output\n#R|      reservoir    S S_LCI S_UCI     Z Z_LCI Z_UCI\n#R|  1 Cedar.Bluff 46.9  42.0  51.9 0.754 0.662 0.846\n#R|  2      Cheney 53.5  48.1  58.9 0.623 0.162 1.085\n#R|  3  Glen.Elder 45.1  42.7  47.4 0.796 0.665 0.927\n#R|  4      Kirwin 39.0  31.1  47.0 0.930 0.732 1.129\n#R|  5    Lovewell 59.5  56.6  62.3 0.519 0.215 0.823\n#R|  6      Marion 59.2  56.5  61.9 0.524 0.308 0.739\n#R|  7     Webster 57.7  50.8  64.7 0.546 0.361 0.731\n#R|  8      Wilson 47.1  42.7  51.5 0.751 0.583 0.919\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}