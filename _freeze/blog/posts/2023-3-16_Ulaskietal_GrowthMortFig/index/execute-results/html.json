{
  "hash": "e23aea83a002c65ae74ec7945ea15475",
  "result": {
    "markdown": "---\ntitle: Ulaski et al. (2022) Growth-Maturity Figure\ndescription: Using ggplot2 to recreate the growth and maturity figure in Ulaski et al. (2022).\nauthor: Derek H. Ogle\ndate: 2/16/2023\nimage: preview.png\ncategories:\n  - ggplot2\n  - Growth\n  - Maturity\n---\n\n\n# Introduction\n\n@ulaskietal_2022 modeled the White Sturgeon (*Acipenser transmontanus*) population in the Sacramento-San Joaquin River Basin to suggest management goals for the population. Their [Figure 1](https://meridian.allenpress.com/view-large/figure/15050079/i1944-687X-13-2-334-f01.tif) showed a modeled von Bertalanffy growth function with shading below the curve that indicated the probability of being mature for each modeled age. I had not seen a plot like this before and set out to recreate it with `ggplot2`.\n\nThis exercise turned out to be more challenging than I thought and I ultimately reached out to Marta Ulaski, the lead author on the paper, to see if their solution was different or \"easier\" than mine. It was different but I learned something with both methods; thus, I will present both here.^[I modified the specifics but kept the overall concept of Ulaski's approach.]\n\n&nbsp;\n\n# Getting Setup\nThe following packages are loaded for use below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)  # for dplyr, ggplot2 packages\n```\n:::\n\n\nThe `ggplot2` theme was set to `theme_bw()` but with a larger base font size and gridlines removed.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntheme_set(\n  theme_bw(base_size=14) +\n  theme(panel.grid=element_blank())\n)\n```\n:::\n\n\n&nbsp;\n\n### Growth Function\nThe three parameters ($L_{\\infty}$, $K$, and $t_{0}$) of a \"typical\" von Bertalanffy growth function (VBGF) provided in the caption to Figure 1 of @ulaskietal_2022 were entered into the `vbpar` named vector.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvbpar <- c(\"Linf\"=380,\"K\"=0.027,\"to\"=-2.36)\n```\n:::\n\n\n`vbFuns()` from `FSA` was used to create a function that returns the mean length-at-age given a set of ages and \"typical\" VBGF parameters.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvb <- FSA::vbFuns('Typical')\nvb\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  function (t, Linf, K = NULL, t0 = NULL) \n#R|  {\n#R|      if (length(Linf) == 3) {\n#R|          K <- Linf[[2]]\n#R|          t0 <- Linf[[3]]\n#R|          Linf <- Linf[[1]]\n#R|      }\n#R|      Linf * (1 - exp(-K * (t - t0)))\n#R|  }\n#R|  <bytecode: 0x0000024ce73eb250>\n#R|  <environment: 0x0000024ce740a940>\n```\n:::\n:::\n\n\nWhile this function appears overly complicated, an advantage of this function is that all three parameters of the typical VBGF can be given to the `Linf=` argument.\n\nBelow is an illustrative example for computing the mean length-at-age given the parameters in `vbpar` for ages 10 and 15.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvb(c(10,15),Linf=vbpar)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  [1] 107.8234 142.1949\n```\n:::\n:::\n\n\n`vb()` will be used in both approaches to making Figure 1 below.\n\n&nbsp;\n\n### Maturity Data\n@ulaskietal_2022 provided probabilities of being mature by age in their [Table 1](https://meridian.allenpress.com/view-large/figure/15050076/i1944-687X-13-2-334-t01.tif). Here I entered those data directly into a data frame, though I multiplied the probabilities by 100 as that is how they are presented in Figure 1. I also added a much older age of 50 to illustrate how this process could be extended to older ages than what was shown in their Figure 1.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat <- data.frame(age=c(0,10:20,50),\n                    prmat=c(0,0.025,0.086,0.143,0.291,0.543,\n                            0.622,0.788,0.849,0.942,0.966,1,1)*100)\ndfmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|     age prmat\n#R|  1    0   0.0\n#R|  2   10   2.5\n#R|  3   11   8.6\n#R|  4   12  14.3\n#R|  5   13  29.1\n#R|  6   14  54.3\n#R|  7   15  62.2\n#R|  8   16  78.8\n#R|  9   17  84.9\n#R|  10  18  94.2\n#R|  11  19  96.6\n#R|  12  20 100.0\n#R|  13  50 100.0\n```\n:::\n:::\n\n\nThe probabilities presented in Figure 1 have been binned into categories. The first category is simply 0% (none mature), but each category after that has a width of 10%. Thus, the next two categories would be from 0.1 to 10%, and 10.1 to 20%. @ulaskietal_2022 chose to label these two categories as \"0-10%\" and \"10-20%\", respectively.\n\nThese categories may be created with `cut()`, which takes the data to categorize as its first argument, the values at which to \"cut\" the categories in `breaks=`, and labels for the categories in `labels=`. It is important to note that `cut()` makes categories right-inclusive by default. Thus, if the breaks are `c(0,10,20)` then the first category would be from 0 to 10, with 10 being inclusive. Thus, a value of 9 or 10 would be included in this category, but 0 would not. Thus, to have a category for just the 0 values, the breaks must start at some negative number (in this case, negative infinity was used).^[`seq(0,100,10)` creates a sequence from 0 to 100 in steps of 10.] The results of `cut()` were added to the `prcuts` variable in `dfmat`.^[Because using `mutate()`.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat <- dfmat |>\n  mutate(prcuts=cut(prmat,\n                    breaks=c(-Inf,seq(0,100,10)),\n                    labels=c(\"0%\",\"0-10%\",\"10-20%\",\"20-30%\",\"30-40%\",\"40-50%\",\n                             \"50-60%\",\"60-70%\",\"70-80%\",\"80-90%\",\"90-100%\")))\ndfmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|     age prmat  prcuts\n#R|  1    0   0.0      0%\n#R|  2   10   2.5   0-10%\n#R|  3   11   8.6   0-10%\n#R|  4   12  14.3  10-20%\n#R|  5   13  29.1  20-30%\n#R|  6   14  54.3  50-60%\n#R|  7   15  62.2  60-70%\n#R|  8   16  78.8  70-80%\n#R|  9   17  84.9  80-90%\n#R|  10  18  94.2 90-100%\n#R|  11  19  96.6 90-100%\n#R|  12  20 100.0 90-100%\n#R|  13  50 100.0 90-100%\n```\n:::\n:::\n\n\n`dfmat` will be used in both approaches to making Figure 1 below.\n\n&nbsp;\n\n### Define Repetitive Values\nFor simplicity, some values that will be used in both approaches were assigned to objects that can be reused.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# x-axis (age) title, limits, labels\nagettl <- \"Age (yrs)\"\nagelmts <- c(0,20)\nagelbls <- 0:20\n# y-axis (length) title, limits, labels\nlenttl <- \"Length (cm)\"\nlenlmts <- c(0,200)\nlenlbls <- seq(0,200,50)\n# fill color (probability mature) title\nprobttl <- \"Probability\"\n```\n:::\n\n\n&nbsp;\n\n# My Recreation of Figure 1\n### Plotting the von B function\nThe typical VBGF can be plotted over the range of ages in a data frame with `stat_function()`.^[Make sure to map the age variable to the `x` aesthetic.] The function to be evaluated (i.e., `vb()`) is given in `fun=` and any arguments that it requires are given in a list to `args=`.^[Here we can set `vbpar` to just `Linf` given that all parameters can be given to this one argument as shown above.] The smoothness of the curve can be controlled with `n=`, which is the number of ages over the range of ages for which the function will be evaluated.^[`n=` defaults to 101, which appeared adequate for these data, though I increased it here to demonstrate its use.] Finally, I increased the line width slightly.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=dfmat,mapping=aes(x=age)) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  stat_function(fun=vb,args=list(Linf=vbpar),\n                n=202,linewidth=0.75)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-vonB-line-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nAs seen above, `stat_function()` defaults to drawing a line of the function (i.e., it uses `geom_line()`). However, other geoms can be used; e.g., `geom=\"area\"`.^[I used `fill=` here to show the effect, but this also required setting `color=` because the color for the line took on the fill color.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=data.frame(age=c(0,20)),mapping=aes(x=age)) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  stat_function(fun=vb,args=list(Linf=vbpar),\n                n=202,linewidth=0.75,\n                geom=\"area\",fill=\"salmon\",color=\"black\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-vonB-area-1.png){fig-align='center' width=576}\n:::\n:::\n\n\n&nbsp;\n\n### Adding the Maturity Scale\nMy solutions to recreating Figure 1 of @ulaskietal_2022 generally followed the StackOverflow answer at the bottom of [this question](https://stackoverflow.com/questions/33244629/filling-under-the-a-curve-with-ggplot-graphs). This process uses `after_stat()` and `after_scale()`, which were introduced to `ggplot2` in v3.3.0.^[See their introduction [here](https://www.tidyverse.org/blog/2020/03/ggplot2-3-3-0/#more-control-over-aesthetic-evaluation).] I don't yet fully understand these two functions, but will try to explain what I think they are doing.\n\nAs illustrated above, `stat_function()` produces a smooth curve by creating `n=` values of `x` over the range of the variable mapped to the `x=` aesthetic. One part of the \"trick\" to this solution is to first realize that these \"age\" values created by `stat_function()` are not integers and, thus, they need to be \"cut\" into integer age categories. The second part of the \"trick\" to this solution is that the probability of maturity category labels should be used for the \"cuts\" of age rather than labels of age. For example, an age of 13.5 created by `stat_function()` should be categorized as an age of 13 but labeled with \"20-30%\".^[Examine `dfmat` to see why.] This cutting of the age values comes after they have been created by `stat_function()` in the `x=` aesthetic and are thus accessed by `after_stat(x)` which I pipe into `cut()` and set equal to the `fill=` aesthetic in `stat_function()`.\n\nThe third part of the \"trick\" to this solution is to realize that the different colored areas can only be plotted if the `group=` aesthetic is set to the same categories used in the `fill=` aesthetic. As the `fill=` aesthetic was just created and is defined in a `scale` (see `scale_fill_viridis_d()` below), the `group=` aesthetic must be defined with `after_scale(fill)`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=dfmat,mapping=aes(x=age)) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  stat_function(mapping=aes(fill=after_stat(x) |>\n                              cut(breaks=!!dfmat$age,\n                                  labels=!!dfmat$prcuts[-nrow(dfmat)],\n                                  include.lowest=TRUE),\n                            group=after_scale(fill)),\n                fun=vb,args=list(Linf=vbpar),n=202,\n                geom=\"area\",color=\"black\",linewidth=0.75)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/figure-1-DHO-1-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThis, obviously, is not ideal ... largely due to the long name for the legend. However, it is also not the colors used in Figure 1 of @ulaskietal_2022. A custom viridis-based color scheme was used in @ulaskietal_2022,^[I would not have \"discovered\" this color scheme on my own. This came from seeing Ulaski's original code.] which can be used with `scale_fill_viridis_d()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=dfmat,mapping=aes(x=age)) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  stat_function(mapping=aes(fill=after_stat(x) |>\n                              cut(breaks=!!dfmat$age,\n                                  labels=!!dfmat$prcuts[-nrow(dfmat)],\n                                  include.lowest=TRUE),\n                            group=after_scale(fill)),\n                fun=vb,args=list(Linf=vbpar),n=202,\n                geom=\"area\",color=\"black\",linewidth=0.75) +\n  scale_fill_viridis_d(name=probttl,begin=0.85,end=0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/figure-1-DHO-2-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nFinally, there are two things with this plot that I don't like. First, the black line for the growth function appears broken at the color breaks. Second, the linewidth around the colors in the legend is too thick. To correct these issues, I removed `linewidth=` and `color=` from `stat_function()` and then added a second `stat_function()` that plots just the growth function as a line.^[See the first use of `stat_function()` further above for how this was done.] This second use of `stat_function()` lays the function line on top of the function \"area.\"\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=dfmat,mapping=aes(x=age)) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  stat_function(mapping=aes(fill=after_stat(x) |>\n                              cut(breaks=!!dfmat$age,\n                                  labels=!!dfmat$prcuts[-nrow(dfmat)],\n                                  include.lowest=TRUE),\n                            group=after_scale(fill)),\n                fun=vb,args=list(Linf=vbpar),n=202,\n                geom=\"area\") +\n  scale_fill_viridis_d(name=probttl,begin=0.85,end=0) +\n  stat_function(fun=vb,args=list(Linf=vbpar),n=202,\n                color=\"black\",linewidth=0.75)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/figure-1-DHO-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n:::{.callout-note appearance=\"simple\"}\n### Future Updates?\nI may update this post as I learn more about `after_stat()` and `after_scale()`.\n:::\n&nbsp;\n\n# Author's Creation of Figure 1\n\n:::{.callout-important appearance=\"simple\"}\n## Acknowledgment\nThe solution in this section follows the concept of the code provided to me by Marta Ulaski, the lead author on the original paper. I have modified the specific code to better fit the rest of the post. I thank Marta for generously providing her source code and allowing me to modify it for presentation here.\n:::\n\n&nbsp;\n\n### Making the Data Frame\n\n:::{.callout-important appearance=\"simple\"}\nSince originally posting this example I have discovered a much easier way to make the data frame created in this section. Please see [this edit below](#different-method-to-construct-authors-data-frame) for that easier method.\n:::\n\nUlaski's solution to making this figure is much simpler to explain (Thank you!) but relies on explicitly creating a data frame that is largely what `stat_function()` did behind-the-scenes. Specifically, Ulaski created a data frame that repeated the probability of being mature for all ages in increments of 0.1. So, for example, this data frame contained an age of 12.3 with the probability of being mature being the same as that for age 12. To generalize this solution I set out to see if I could create this data frame from the simple `dfmat` created above.^[Ulaski had manually created a CSV with these repeated data, which were read in to a data frame.] This posed some challenges.\n\nThe first challenge was that I needed a way to create the sequence of ages between successive ages in `dfmat`. For example, between ages 0 and 10, I needed to create 99 ages that looked like 0, 0.1, 0.2, ..., 9.7, 9.8, and 9.9, whereas between 10 and 11 I only needed to create 9 ages that looked like 10, 10.1, ... 10.7, 10.8, 10.9. I am not aware of a function to do this in R so I wrote the simple function below to accomplish this task for all ages in `x` in increments given in `by=`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nseq_prs <- function(x,by) {\n  # initiate result\n  res <- NULL\n  # cycle through successive ages, create sequence, make sure not to include\n  #   second age (it will be first on next iteration), append to res\n  for (i in 1:(length(x)-1)) {\n    res <- c(res,seq(x[i],x[i+1]-by,by=by))\n  }\n  # include last age (it was left off in the loop), return the result\n  c(res,x[length(x)])\n}\n```\n:::\n\n\nThis function was used to create the sequence of \"fractional\" ages for the ages in `dfmat`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nby <- 0.1\nagef <- seq_prs(dfmat$age,by)\nagef\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|    [1]  0.0  0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1.0  1.1  1.2  1.3  1.4\n#R|   [16]  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3  2.4  2.5  2.6  2.7  2.8  2.9\n#R|   [31]  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9  4.0  4.1  4.2  4.3  4.4\n#R|   [46]  4.5  4.6  4.7  4.8  4.9  5.0  5.1  5.2  5.3  5.4  5.5  5.6  5.7  5.8  5.9\n#R|   [61]  6.0  6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9  7.0  7.1  7.2  7.3  7.4\n#R|   [76]  7.5  7.6  7.7  7.8  7.9  8.0  8.1  8.2  8.3  8.4  8.5  8.6  8.7  8.8  8.9\n#R|   [91]  9.0  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9 10.0 10.1 10.2 10.3 10.4\n#R|  [106] 10.5 10.6 10.7 10.8 10.9 11.0 11.1 11.2 11.3 11.4 11.5 11.6 11.7 11.8 11.9\n#R|  [121] 12.0 12.1 12.2 12.3 12.4 12.5 12.6 12.7 12.8 12.9 13.0 13.1 13.2 13.3 13.4\n#R|  [136] 13.5 13.6 13.7 13.8 13.9 14.0 14.1 14.2 14.3 14.4 14.5 14.6 14.7 14.8 14.9\n#R|  [151] 15.0 15.1 15.2 15.3 15.4 15.5 15.6 15.7 15.8 15.9 16.0 16.1 16.2 16.3 16.4\n#R|  [166] 16.5 16.6 16.7 16.8 16.9 17.0 17.1 17.2 17.3 17.4 17.5 17.6 17.7 17.8 17.9\n#R|  [181] 18.0 18.1 18.2 18.3 18.4 18.5 18.6 18.7 18.8 18.9 19.0 19.1 19.2 19.3 19.4\n#R|  [196] 19.5 19.6 19.7 19.8 19.9 20.0 20.1 20.2 20.3 20.4 20.5 20.6 20.7 20.8 20.9\n#R|  [211] 21.0 21.1 21.2 21.3 21.4 21.5 21.6 21.7 21.8 21.9 22.0 22.1 22.2 22.3 22.4\n#R|  [226] 22.5 22.6 22.7 22.8 22.9 23.0 23.1 23.2 23.3 23.4 23.5 23.6 23.7 23.8 23.9\n#R|  [241] 24.0 24.1 24.2 24.3 24.4 24.5 24.6 24.7 24.8 24.9 25.0 25.1 25.2 25.3 25.4\n#R|  [256] 25.5 25.6 25.7 25.8 25.9 26.0 26.1 26.2 26.3 26.4 26.5 26.6 26.7 26.8 26.9\n#R|  [271] 27.0 27.1 27.2 27.3 27.4 27.5 27.6 27.7 27.8 27.9 28.0 28.1 28.2 28.3 28.4\n#R|  [286] 28.5 28.6 28.7 28.8 28.9 29.0 29.1 29.2 29.3 29.4 29.5 29.6 29.7 29.8 29.9\n#R|  [301] 30.0 30.1 30.2 30.3 30.4 30.5 30.6 30.7 30.8 30.9 31.0 31.1 31.2 31.3 31.4\n#R|  [316] 31.5 31.6 31.7 31.8 31.9 32.0 32.1 32.2 32.3 32.4 32.5 32.6 32.7 32.8 32.9\n#R|  [331] 33.0 33.1 33.2 33.3 33.4 33.5 33.6 33.7 33.8 33.9 34.0 34.1 34.2 34.3 34.4\n#R|  [346] 34.5 34.6 34.7 34.8 34.9 35.0 35.1 35.2 35.3 35.4 35.5 35.6 35.7 35.8 35.9\n#R|  [361] 36.0 36.1 36.2 36.3 36.4 36.5 36.6 36.7 36.8 36.9 37.0 37.1 37.2 37.3 37.4\n#R|  [376] 37.5 37.6 37.7 37.8 37.9 38.0 38.1 38.2 38.3 38.4 38.5 38.6 38.7 38.8 38.9\n#R|  [391] 39.0 39.1 39.2 39.3 39.4 39.5 39.6 39.7 39.8 39.9 40.0 40.1 40.2 40.3 40.4\n#R|  [406] 40.5 40.6 40.7 40.8 40.9 41.0 41.1 41.2 41.3 41.4 41.5 41.6 41.7 41.8 41.9\n#R|  [421] 42.0 42.1 42.2 42.3 42.4 42.5 42.6 42.7 42.8 42.9 43.0 43.1 43.2 43.3 43.4\n#R|  [436] 43.5 43.6 43.7 43.8 43.9 44.0 44.1 44.2 44.3 44.4 44.5 44.6 44.7 44.8 44.9\n#R|  [451] 45.0 45.1 45.2 45.3 45.4 45.5 45.6 45.7 45.8 45.9 46.0 46.1 46.2 46.3 46.4\n#R|  [466] 46.5 46.6 46.7 46.8 46.9 47.0 47.1 47.2 47.3 47.4 47.5 47.6 47.7 47.8 47.9\n#R|  [481] 48.0 48.1 48.2 48.3 48.4 48.5 48.6 48.7 48.8 48.9 49.0 49.1 49.2 49.3 49.4\n#R|  [496] 49.5 49.6 49.7 49.8 49.9 50.0\n```\n:::\n:::\n\n\nThe second challenge is that the rows of `dfmat` needed to be appropriately repeated for each of the \"fractional\" ages just computed. The number of times to repeat each row is found by dividing the difference between successive ages in `dfmat` by the increment value used for creating the \"fractional\" ages. The result below shows that the age-0 (first) row should be repeated 100 times, the age-1 (second) row 10 times, etc.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndiff(dfmat$age)/by\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|   [1] 100  10  10  10  10  10  10  10  10  10  10 300\n```\n:::\n:::\n\n\nI then created an index of row numbers^[Created with `1:nrow(dfmat)`.] repeated the appropriate number of times. Note that 1 had to be appended to the repeat values so that the last age appeared once in these indices.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrepinds <- rep(1:nrow(dfmat),c(diff(dfmat$age)/by,1))\nrepinds\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|    [1]  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n#R|   [26]  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n#R|   [51]  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n#R|   [76]  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n#R|  [101]  2  2  2  2  2  2  2  2  2  2  3  3  3  3  3  3  3  3  3  3  4  4  4  4  4\n#R|  [126]  4  4  4  4  4  5  5  5  5  5  5  5  5  5  5  6  6  6  6  6  6  6  6  6  6\n#R|  [151]  7  7  7  7  7  7  7  7  7  7  8  8  8  8  8  8  8  8  8  8  9  9  9  9  9\n#R|  [176]  9  9  9  9  9 10 10 10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 11 11\n#R|  [201] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12\n#R|  [226] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12\n#R|  [251] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12\n#R|  [276] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12\n#R|  [301] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12\n#R|  [326] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12\n#R|  [351] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12\n#R|  [376] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12\n#R|  [401] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12\n#R|  [426] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12\n#R|  [451] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12\n#R|  [476] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12\n#R|  [501] 13\n```\n:::\n:::\n\n\nA new data frame is then created from `dfmat` using these repeated row indices.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat2 <- dfmat[repinds,]\nFSA::headtail(dfmat2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|         age prmat  prcuts\n#R|  1        0     0      0%\n#R|  1.1      0     0      0%\n#R|  1.2      0     0      0%\n#R|  12.298  20   100 90-100%\n#R|  12.299  20   100 90-100%\n#R|  13      50   100 90-100%\n```\n:::\n:::\n\n\nFinally, the data frame used by Ulaski is completed by appending the fractional age vector and creating a vector of predicted lengths at each fractional age.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat2 <- dfmat2 |>\n  mutate(agef=agef,\n         len=vb(agef,Linf=vbpar))\nFSA::headtail(dfmat2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|         age prmat  prcuts agef       len\n#R|  1        0     0      0%  0.0  23.45828\n#R|  1.1      0     0      0%  0.1  24.41965\n#R|  1.2      0     0      0%  0.2  25.37842\n#R|  12.298  20   100 90-100% 49.8 287.06956\n#R|  12.299  20   100 90-100% 49.9 287.32013\n#R|  13      50   100 90-100% 50.0 287.57003\n```\n:::\n:::\n\n\n&nbsp;\n\n### Making the Figure\nFigure 1 is then simply created by mapping the fractional ages (i.e., `agef`) to `x=` and the lengths to `y`, mapping the probability cuts to `fill=` in `geom_ares()`, and including `geom_line()` (with a slightly larger line width).^[This will produce a warning because the data frame extends to age 50 but the figure is limited to age 20.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=dfmat2,mapping=aes(x=agef,y=len)) + \n  geom_area(mapping=aes(fill=prcuts)) + \n  geom_line(linewidth=0.75) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  scale_fill_viridis_d(name=\"Probability\",begin=0.85,end=0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/figure-1-MU-1.png){fig-align='center' width=672}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n&nbsp;\n\n# Further Thoughts\nThere are a few things that I would like to see different in this figure. First, the \"white\" lines between the colors are too prominent. The size of these lines are a function of the number of \"fractional\" ages used to produce the plot. Thus, to make these \"lines\" thinner one could increase `n=` in my solution or decrease `by=` in the author's solution.\n\nSecond, it bothers me that the colors for the probabilities seem equally spaced even though two categories are not represented in the data (e.g., 30-40% and 40-50%). In my mind, there should be a \"jump\" in colors at the ages where the probability jumps from 20-30% to 50-60% (i.e., between age-13 and age-14).^[This will be a common issue with maturity data as the probability of maturity often increases dramatically over a short range of lengths and, thus, one or very few ages.] I could not address this issue with my solution, but including `drop=FALSE` in `scale_fill_viridis_d()` fixed this in the author's solution.\n\nThird, the \"line\" does not look like a typical VBGF to me as these sturgeon are long-lived and grow so slowly that very little curvature and no asymptote is evident. In some situations is may be useful to extend the x-axis to older ages to better \"see\" the typical asymptotic growth of the VBGF.^[This is not that useful here given the shape of the VBGF for this species.]\n\nFinally, the authors started their plot age-1. I am not sure why they did this, but that can be accomplished by filtering the data to only age-1 and older.\n\nAll of these changes (with `by=0.01` and extending the ages to 30) were made below using the author's solution.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nagelmts <- c(0,30)                                   # changed max\nagelbls <- seq(0,30,2)                               # changed max, made sequence by 2\nlenlmts <- c(0,250)                                  # changed max\nlenlbls <- seq(0,250,50)                             # changed max\n\nby <- 0.01                                           # made smaller\nagef <- seq_prs(dfmat$age,by)\nrepinds <- rep(1:nrow(dfmat),c(diff(dfmat$age)/by,1))\n\ndfmat3 <- dfmat[repinds,] |>  # changed name to dfmat3\n  mutate(agef=agef,\n         len=vb(agef,Linf=vbpar)) |>\n  filter(agef>=1)             # filtered out <age-1\n\nggplot(data=dfmat3,mapping=aes(x=agef,y=len)) +      # used new dfmat3\n  geom_area(mapping=aes(fill=prcuts)) + \n  geom_line(linewidth=0.75) +\n  scale_x_continuous(name=agettl,limits=agelmts,breaks=agelbls,\n                     expand=expansion(mult=0)) +\n  scale_y_continuous(name=lenttl,limits=lenlmts,breaks=lenlbls,\n                     expand=expansion(mult=0)) +\n  scale_fill_viridis_d(name=\"Probability\",begin=0.85,end=0,drop=FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/figure-1-MU2-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n&nbsp;\n\n# Edits\n### Different Method to Construct Author's Data Frame\nI believe that there is an easier way to construct `dfmat2` used in the author's solution. This edit details that method.\n\nFirst, remember what the original `dfmat` looked like ... ages and probabilities of maturity from Table 1 in the published paper, and categories of probability mature created with `cut()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|     age prmat  prcuts\n#R|  1    0   0.0      0%\n#R|  2   10   2.5   0-10%\n#R|  3   11   8.6   0-10%\n#R|  4   12  14.3  10-20%\n#R|  5   13  29.1  20-30%\n#R|  6   14  54.3  50-60%\n#R|  7   15  62.2  60-70%\n#R|  8   16  78.8  70-80%\n#R|  9   17  84.9  80-90%\n#R|  10  18  94.2 90-100%\n#R|  11  19  96.6 90-100%\n#R|  12  20 100.0 90-100%\n#R|  13  50 100.0 90-100%\n```\n:::\n:::\n\n\nSecond, create a new data frame that has fractional ages that begin at the minimum age in `dfmat`, end at the maximum age in `dfmat`, and has some constant increment (0.1 in this example). Then use `lencat()` from `FSA` to create categories of ages that match the ages in `dfmat`. `lencat()` returns a factor variable by default but use `as.fact=FALSE` to return a number to match the `age` variable in `dfmat`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat2a <- data.frame(agef=seq(min(dfmat$age),max(dfmat$age),0.1)) |>\n  mutate(age=FSA::lencat(agef,breaks=dfmat$age,as.fact=FALSE))\nFSA::headtail(dfmat2a,n=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|      agef age\n#R|  1    0.0   0\n#R|  2    0.1   0\n#R|  3    0.2   0\n#R|  4    0.3   0\n#R|  5    0.4   0\n#R|  497 49.6  20\n#R|  498 49.7  20\n#R|  499 49.8  20\n#R|  500 49.9  20\n#R|  501 50.0  50\n```\n:::\n:::\n\n\nThe probability mature values and categories can be added to this data frame with a `left_join()` using the common `age` variable in `dfmat` and `dfmat2a`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat2a <- dfmat2a |>\n  left_join(dfmat,by=\"age\")\nFSA::headtail(dfmat2a,n=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|      agef age prmat  prcuts\n#R|  1    0.0   0     0      0%\n#R|  2    0.1   0     0      0%\n#R|  3    0.2   0     0      0%\n#R|  4    0.3   0     0      0%\n#R|  5    0.4   0     0      0%\n#R|  497 49.6  20   100 90-100%\n#R|  498 49.7  20   100 90-100%\n#R|  499 49.8  20   100 90-100%\n#R|  500 49.9  20   100 90-100%\n#R|  501 50.0  50   100 90-100%\n```\n:::\n:::\n\n\nFinally, add the predicted mean lengths as before.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat2a <- dfmat2a |>\n  mutate(len=vb(agef,Linf=vbpar))\nFSA::headtail(dfmat2a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|      agef age prmat  prcuts       len\n#R|  1    0.0   0     0      0%  23.45828\n#R|  2    0.1   0     0      0%  24.41965\n#R|  3    0.2   0     0      0%  25.37842\n#R|  499 49.8  20   100 90-100% 287.06956\n#R|  500 49.9  20   100 90-100% 287.32013\n#R|  501 50.0  50   100 90-100% 287.57003\n```\n:::\n:::\n\n\nThis is the same as the original `dfmat2`.^[I rearranged the columns for ease of comparison. Also, the rownames are irrelevant so ignore them.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nFSA::headtail(dfmat2) |> select(agef,age,prmat,prcuts,len)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|         agef age prmat  prcuts       len\n#R|  1       0.0   0     0      0%  23.45828\n#R|  1.1     0.1   0     0      0%  24.41965\n#R|  1.2     0.2   0     0      0%  25.37842\n#R|  12.298 49.8  20   100 90-100% 287.06956\n#R|  12.299 49.9  20   100 90-100% 287.32013\n#R|  13     50.0  50   100 90-100% 287.57003\n```\n:::\n:::\n\n\nIf you use this method rather than the original method to create `dfmethod2` [used above](#making-the-data-frame) then you can combine all of the code of this section into one tight set. Additionally, make sure to save the result as `dfmat2` (as below) before continuing on [to make the figure](#making-the-figure).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndfmat2 <- data.frame(agef=seq(min(dfmat$age),max(dfmat$age),0.1)) |>\n  mutate(age=FSA::lencat(agef,breaks=dfmat$age,as.fact=FALSE)) |>\n  left_join(dfmat,by=\"age\") |>\n  mutate(len=vb(agef,Linf=vbpar))\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}