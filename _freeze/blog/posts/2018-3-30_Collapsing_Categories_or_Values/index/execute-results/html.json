{
  "hash": "d0ef55e8e493c55fafa083c65ba87481",
  "result": {
    "markdown": "---\ntitle: \"Collapsing Categories or Values\"\ndescription: \"How to collapse categories or values into other categories\"\nauthor: \"Derek H. Ogle\"\ndate: \"3/30/2018\"\nimage: \"preview.png\"\ncategories:\n  - Data Wrangling\nknitr: \n  opts_chunk: \n    fig.width: 4\n    fig.height: 4\n---\n\n\n:::{.callout-note}\nThe following packages are loaded for use below. The `plyr` package is also used but it is not loaded because  I am only going to use one specific function from `plyr` (i.e., `mapvalues()`).]\n:::\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(dplyr)   # for mutate(), case_when()\nlibrary(forcats) # for fct_recode(), fct_collapse()\n```\n:::\n\n\n&nbsp;\n\n# Introduction\nI have received a few queries recently that can be categorized as \"How do I collapse a list of categories or values into a shorter list of categories or values?\" For example, one user wanted to collapse species of fish into their respective families. Another user wanted to collapse years into decades. Data wrangling such as this is common in fisheries and is briefly described below.\n\n&nbsp;\n\n# Sample Data\nThe following creates a very simple sample of 250 individuals on which the species (as a short abbreviation) and year of capture were recorded. Because I am creating random example data below, I set the random number seed to make the results reproducible.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(678394)  # for reproducibility of random data\nn <- 250          # to allow easily changing sample size\ndat <- data.frame(species=sample(c(\"BLG\",\"LMB\",\"PKS\",\"WAE\",\"YEP\",\"CRP\"),\n                                 n,replace=TRUE),\n                  year=sample(1980:2017,n,replace=TRUE))\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|    species year\n#R|  1     YEP 1996\n#R|  2     PKS 2005\n#R|  3     PKS 2013\n#R|  4     YEP 2014\n#R|  5     CRP 2016\n#R|  6     PKS 2006\n```\n:::\n:::\n\n\n&nbsp;\n\n# Recode Categories\nThis example demonstrates how to change the codes in one variable (e.g., species abbreviations) to new codes in another variable (e.g., long species names).\n\nBefore recoding I find it easier to create a vector that contains the original codes to convert from. For example, `unique()` extracts the vector of species abbreviations found in the `species` variable of the example data, which I then saved in `short` and alphabetized to make the next steps easier.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshort <- unique(dat$species) |>\n  sort()\nshort\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  [1] \"BLG\" \"CRP\" \"LMB\" \"PKS\" \"WAE\" \"YEP\"\n```\n:::\n:::\n\n\nIn addition, I also create a vector of codes that these codes will be converted to. For example, the `long` vector below contains the long-form names for each species (in the same order as the abbreviations in `short`)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlong <- c(\"Bluegill\",\"Carp\",\"Largemouth Bass\",\n          \"Pumpkinseed\",\"Walleye\",\"Yellow Perch\")\n```\n:::\n\n\nYou should \"column-bind\" these two vectors together to ensure that the codes align.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncbind(short,long)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|       short long             \n#R|  [1,] \"BLG\" \"Bluegill\"       \n#R|  [2,] \"CRP\" \"Carp\"           \n#R|  [3,] \"LMB\" \"Largemouth Bass\"\n#R|  [4,] \"PKS\" \"Pumpkinseed\"    \n#R|  [5,] \"WAE\" \"Walleye\"        \n#R|  [6,] \"YEP\" \"Yellow Perch\"\n```\n:::\n:::\n\n\nThe `mapvalues()` function (from `plyr`) may be used to efficiently recode character (or factor) values.^[The use of `plyr::` in front of `mapvalues()` ensures that `mapvalues()` from `plyr` and not another package will be used and allows for not loading the entire `plyr` package.] Because `mapvalues()` operates on a vector, it should be used within `mutate()` (from `dplyr`) to add a new variable with the recoded values to a data frame. Within `mutate()` the first argument to `mapvalues()` is the variable that contains the original data to be recoded. A vector of categories to code from is given in `from=` and a vector of **new** categories to code to is given in `to=`. For example, the combined use of `mutate()` and `mapvalues()` below demonstrates creating a new variable in the data frame with the long species names.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat <- dat |>\n  mutate(speciesL=plyr::mapvalues(species,from=short,to=long))\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|    species year     speciesL\n#R|  1     YEP 1996 Yellow Perch\n#R|  2     PKS 2005  Pumpkinseed\n#R|  3     PKS 2013  Pumpkinseed\n#R|  4     YEP 2014 Yellow Perch\n#R|  5     CRP 2016         Carp\n#R|  6     PKS 2006  Pumpkinseed\n```\n:::\n:::\n\n\n&nbsp;\n\n:::{.callout-information}\nThis use of `mapvalues()` and `mutate()` is described in Section 2.2.7 of my book [Introductory Fisheries Analyses with R](http://derekogle.com/IFAR/).\n:::\n\n&nbsp;\n\nThe `fct_recode()` function (from `forcats`) can also be used to recode categories. Within `mutate()` the first argument to `fct_recode()` is the original factor variable. Subsequent arguments are of the form new level name equal to old level name.^[Any levels not listed in `fct_recode()` will be retained with their original names.] For example, the same recoding to long species name is shown below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat <- dat |>\n  mutate(speciesL2=fct_recode(species,\n                              \"Bluegill\" = \"BLG\",\n                              \"Carp\" = \"CRP\",\n                              \"Largemouth Bass\" = \"LMB\",\n                              \"Pumpkinseed\" = \"PKS\",\n                              \"Walleye\" = \"WAE\",\n                              \"Yellow Perch\" = \"YEP\"))\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|    species year     speciesL    speciesL2\n#R|  1     YEP 1996 Yellow Perch Yellow Perch\n#R|  2     PKS 2005  Pumpkinseed  Pumpkinseed\n#R|  3     PKS 2013  Pumpkinseed  Pumpkinseed\n#R|  4     YEP 2014 Yellow Perch Yellow Perch\n#R|  5     CRP 2016         Carp         Carp\n#R|  6     PKS 2006  Pumpkinseed  Pumpkinseed\n```\n:::\n:::\n\n\n&nbsp;\n\n# Collapse Categories\nIn some instances, one may want to collapse some categories into a single category (e.g., species into a family). This is easily accomplished with `mapvalues()` or `fct_recode()` by simply repeating some of the \"to\" categories. For example, `family` contains family names that correspond to the species names in the data frame. Note how multiple species have the same family name category.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfam <- c(\"Centrarchidae\",\"Cyprinidae\",\"Centrarchidae\",\n         \"Centrarchidae\",\"Percidae\",\"Percidae\")\ncbind(short,long,fam)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|       short long              fam            \n#R|  [1,] \"BLG\" \"Bluegill\"        \"Centrarchidae\"\n#R|  [2,] \"CRP\" \"Carp\"            \"Cyprinidae\"   \n#R|  [3,] \"LMB\" \"Largemouth Bass\" \"Centrarchidae\"\n#R|  [4,] \"PKS\" \"Pumpkinseed\"     \"Centrarchidae\"\n#R|  [5,] \"WAE\" \"Walleye\"         \"Percidae\"     \n#R|  [6,] \"YEP\" \"Yellow Perch\"    \"Percidae\"\n```\n:::\n:::\n\n\nThe example below shows how to convert the species name abbreviations to family names. In addition, the last use of `mapvalues()` shows how to change the long-form names to family names. This last example is, of course, repetitive, but it is used here to demonstrate how `mutate()` allows a variable that was \"just created\" to be immediately used.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat <- dat |>\n  mutate(family=plyr::mapvalues(species,from=short,to=fam),\n         family2=plyr::mapvalues(speciesL,from=long,to=fam))\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|    species year     speciesL    speciesL2        family       family2\n#R|  1     YEP 1996 Yellow Perch Yellow Perch      Percidae      Percidae\n#R|  2     PKS 2005  Pumpkinseed  Pumpkinseed Centrarchidae Centrarchidae\n#R|  3     PKS 2013  Pumpkinseed  Pumpkinseed Centrarchidae Centrarchidae\n#R|  4     YEP 2014 Yellow Perch Yellow Perch      Percidae      Percidae\n#R|  5     CRP 2016         Carp         Carp    Cyprinidae    Cyprinidae\n#R|  6     PKS 2006  Pumpkinseed  Pumpkinseed Centrarchidae Centrarchidae\n```\n:::\n:::\n\n\nThe “collapsing” of multiple levels into one level can also be accomplished with `fct_collapse()` (from `forcats`). The first argument to this function is again the variable containing the “old” levels. Subsequent arguments are formed by setting a new level name equal to a vector containing old level names to collapse.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat <- dat |>\n  mutate(family3=fct_collapse(species,\n                              \"Centarchidae\" = c(\"BLG\",\"PKS\",\"LMB\"),\n                              \"Percidae\" = c(\"WAE\",\"YEP\"),\n                              \"Cyprinidae\" = c(\"CRP\")))\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|    species year     speciesL    speciesL2        family       family2\n#R|  1     YEP 1996 Yellow Perch Yellow Perch      Percidae      Percidae\n#R|  2     PKS 2005  Pumpkinseed  Pumpkinseed Centrarchidae Centrarchidae\n#R|  3     PKS 2013  Pumpkinseed  Pumpkinseed Centrarchidae Centrarchidae\n#R|  4     YEP 2014 Yellow Perch Yellow Perch      Percidae      Percidae\n#R|  5     CRP 2016         Carp         Carp    Cyprinidae    Cyprinidae\n#R|  6     PKS 2006  Pumpkinseed  Pumpkinseed Centrarchidae Centrarchidae\n#R|         family3\n#R|  1     Percidae\n#R|  2 Centarchidae\n#R|  3 Centarchidae\n#R|  4     Percidae\n#R|  5   Cyprinidae\n#R|  6 Centarchidae\n```\n:::\n:::\n\n\n&nbsp;\n\n# Collapse Values into Categories\nIt is also common to categorize a numeric variable. For example, a \"decade\" variable is derived from the year variable in this example.\n\nThe `case_when()` function (from `dplyr`) may be used to efficiently collapse discrete values into categories. This function also operates on vectors and, thus, must be used with `mutate()` to add a variable to a data frame. The arguments to `case_when()` are a series of two-sided formulae where the left-side is a conditioning statement based on the original data and the right-side is the value that should appear in the new variable when that condition is `TRUE`. For example, the first line in `case_when()` below asks \"if the year variable is in the values from 1980 to 1989 then the new category should be '1980s'.\"^[The colon operator creates a sequence of all integers between the two numbers separated by the colon. The `%in%` is used on conditional statements to determine if a value is contained within a vector, returning `TRUE` if it is and `FALSE` if it is not.] For example, the code below creates a new variable called `decade` that identifies the decade that corresponds to the year-of-capture variable.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat <- dat |>\n  mutate(decade=case_when(\n    year %in% 1980:1989 ~ \"1980s\",\n    year %in% 1990:1999 ~ \"1990s\",\n    year %in% 2000:2009 ~ \"2000s\",\n    year %in% 2010:2019 ~ \"2010s\"\n  ))\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|    species year     speciesL    speciesL2        family       family2\n#R|  1     YEP 1996 Yellow Perch Yellow Perch      Percidae      Percidae\n#R|  2     PKS 2005  Pumpkinseed  Pumpkinseed Centrarchidae Centrarchidae\n#R|  3     PKS 2013  Pumpkinseed  Pumpkinseed Centrarchidae Centrarchidae\n#R|  4     YEP 2014 Yellow Perch Yellow Perch      Percidae      Percidae\n#R|  5     CRP 2016         Carp         Carp    Cyprinidae    Cyprinidae\n#R|  6     PKS 2006  Pumpkinseed  Pumpkinseed Centrarchidae Centrarchidae\n#R|         family3 decade\n#R|  1     Percidae  1990s\n#R|  2 Centarchidae  2000s\n#R|  3 Centarchidae  2010s\n#R|  4     Percidae  2010s\n#R|  5   Cyprinidae  2010s\n#R|  6 Centarchidae  2000s\n```\n:::\n:::\n\n\nThe lines in `case_when()` operate sequentially (like a series of \"if\" statements) such that the above operation can be more succinctly coded as below. Also note in this example that the resulting variable is numeric rather than categorical (simply as an example).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat <- dat |>\n  mutate(decade2=case_when(\n    year <= 1989 ~ 1980,\n    year <= 1999 ~ 1990,\n    year <= 2009 ~ 2000,\n    year <= 2019 ~ 2010,\n  ))\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|    species year     speciesL    speciesL2        family       family2\n#R|  1     YEP 1996 Yellow Perch Yellow Perch      Percidae      Percidae\n#R|  2     PKS 2005  Pumpkinseed  Pumpkinseed Centrarchidae Centrarchidae\n#R|  3     PKS 2013  Pumpkinseed  Pumpkinseed Centrarchidae Centrarchidae\n#R|  4     YEP 2014 Yellow Perch Yellow Perch      Percidae      Percidae\n#R|  5     CRP 2016         Carp         Carp    Cyprinidae    Cyprinidae\n#R|  6     PKS 2006  Pumpkinseed  Pumpkinseed Centrarchidae Centrarchidae\n#R|         family3 decade decade2\n#R|  1     Percidae  1990s    1990\n#R|  2 Centarchidae  2000s    2000\n#R|  3 Centarchidae  2010s    2010\n#R|  4     Percidae  2010s    2010\n#R|  5   Cyprinidae  2010s    2010\n#R|  6 Centarchidae  2000s    2000\n```\n:::\n\n```{.r .cell-code}\nstr(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  'data.frame':\t250 obs. of  9 variables:\n#R|   $ species  : chr  \"YEP\" \"PKS\" \"PKS\" \"YEP\" ...\n#R|   $ year     : int  1996 2005 2013 2014 2016 2006 2002 2012 2013 2014 ...\n#R|   $ speciesL : chr  \"Yellow Perch\" \"Pumpkinseed\" \"Pumpkinseed\" \"Yellow Perch\" ...\n#R|   $ speciesL2: Factor w/ 6 levels \"Bluegill\",\"Carp\",..: 6 4 4 6 2 4 5 1 3 6 ...\n#R|   $ family   : chr  \"Percidae\" \"Centrarchidae\" \"Centrarchidae\" \"Percidae\" ...\n#R|   $ family2  : chr  \"Percidae\" \"Centrarchidae\" \"Centrarchidae\" \"Percidae\" ...\n#R|   $ family3  : Factor w/ 3 levels \"Centarchidae\",..: 3 1 1 3 2 1 3 1 1 3 ...\n#R|   $ decade   : chr  \"1990s\" \"2000s\" \"2010s\" \"2010s\" ...\n#R|   $ decade2  : num  1990 2000 2010 2010 2010 2000 2000 2010 2010 2010 ...\n```\n:::\n:::\n\n\n&nbsp;\n\n:::{.callout-warning}\nYou may be motivated from this example to use `case_when()` to develop a length category variable from measure lengths. While this is possible it is not efficient as you would have several conditions within `case_when()` (to span all measured lengths) and you would need to make sure that your conditions covered the range of measured lengths. I urge you to examine `lencat()` in `FSA` for the purpose of creating length categories ([see examples here](https://fishr-core-team.github.io/FSA/reference/lencat.html)).\n:::\n\n&nbsp;\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}