{
  "hash": "1600d5310d737cc1f94d7ede6a7d5fb5",
  "result": {
    "markdown": "---\ntitle: von Bertalanffy Growth Plots II\ndescription: How to plot multiple von Bertalanffy growth models with data.\nauthor: Derek H. Ogle\ndate: 1/2/2019\nimage: preview.png\ncategories:\n  - Age\n  - Growth\n  - Size\n  - ggplot2\nknitr: \n  opts_chunk:\n    fig.width: 4\n    fig.height: 4\n---\n\n\n:::{.callout-note}\nThe following packages are loaded for use below. The data are also from `FSAdata`, which is not loaded below. I also set the default `ggplot` theme to `theme_bw()` for a classic \"black-and-white\" plot (rather than the default plot with a gray background).\n:::\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(FSA)     # for vbFuns(), vbStarts(), confint.bootCase(), headtail()\nlibrary(car)     # for Boot()\nlibrary(dplyr)   # for filter(), mutate()\nlibrary(ggplot2)\ntheme_set(theme_bw())\n```\n:::\n\n\n&nbsp;\n\n# Introduction\nIn [a previous post]() I demonstrated how to plot the fit of a von Bertalanffy growth function (VBGF) for a single group of observed data. In this post, I explore methods to do the same for multiple groups of observed data (e.g., multiple sexes, locations, years).\n\nI will again use the lengths and ages of Lake Erie Walleye (*Sander vitreus*) captured during October-November, 2003-2014 available in [`FSAdata`](https://fishr-core-team.github.io/FSAdata/) package. These data formed many of the examples in @ogle_growth_2017. My primary interest here is in the `tl` (total length in mm), `age`, and `sex` variables^[See [more details about the data](https://fishr-core-team.github.io/FSAdata/reference/WalleyeErie2.html).]. I initially focus on Walleye from location \"1\" captured in 2014 in this example.^[For succinctness, I removed `year` as it only had one level after filtering and three variables related to the `loc`ation of capture.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(WalleyeErie2,package=\"FSAdata\")\nw14T <- WalleyeErie2 |>\n  filter(year==2014,loc==1) |>\n  select(-year,-setID,-loc,-grid)\nheadtail(w14T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|       tl    w    sex      mat age\n#R|  1   445  737 female immature   2\n#R|  2   528 1571 female   mature   4\n#R|  3   499 1138   male   mature   4\n#R|  612 521 1408 female   mature   3\n#R|  613 565 1745 female   mature   3\n#R|  614 530 1553   male   mature   5\n```\n:::\n:::\n\n\nAs in the previous post, a function that uses the typical VBGF to predict mean length given a set of VBGF parameters and age is needed.^[Other parameterizations of the VBGF can be used with `param=` in `vbFuns()` as described in [its documentation](https://fishr-core-team.github.io/FSA/reference/growthModels.html).]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n( vb <- vbFuns(param=\"Typical\") )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  function (t, Linf, K = NULL, t0 = NULL) \n#R|  {\n#R|      if (length(Linf) == 3) {\n#R|          K <- Linf[[2]]\n#R|          t0 <- Linf[[3]]\n#R|          Linf <- Linf[[1]]\n#R|      }\n#R|      Linf * (1 - exp(-K * (t - t0)))\n#R|  }\n#R|  <bytecode: 0x0000021bacf7c9a0>\n#R|  <environment: 0x0000021bacfb6f90>\n```\n:::\n:::\n\n\n&nbsp;\n\n# Model Fits Using `geom_smooth()`\nOne of the simpler ways to plot multiple VBGF fits uses `geom_smooth()`, which, as described in the previous post, uses `nls()` to fit the model \"behind-the-scenes.\" Given this uses of `nls()` a set of starting values is needed. It is critical to note, though, that this method will only work if the **same** starting values can be used for each group in the data. With this warning, possible starting values for the optimization algorithm may be obtained with `vbStarts()`, where the first argument is a formula of the form `lengths~ages` where `lengths` and `ages` are replaced with the actual variable names that contain the observed lengths and ages, respectively, and `data=` is set to the data frame that contains those variables.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n( f.starts <- vbStarts(tl~age,data=w14T) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  $Linf\n#R|  [1] 591.1587\n#R|  \n#R|  $K\n#R|  [1] 0.3930388\n#R|  \n#R|  $t0\n#R|  [1] -1.544479\n```\n:::\n:::\n\n\nThe use of `geom_smooth()` to produce separate lines for the groups is exactly as described in the previous post except that the variable to identify the groups (i.e., `sex` in this example) must be mapped to the `color=` `aes()`thetic. For @fig-sex1 I also used `scale_color_manual()` to demonstrate how to change colors of the points and lines. Addition, I altered the theme to move the legend/guide into the plot panel and to remove the default `sex` label that would appear on top of the legend.^[In this case the legend is placed 80% down the x-axis and 20% up the y-axis.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=w14T,aes(x=age,y=tl,color=sex)) +\n  geom_point(size=2,alpha=0.3) +\n  scale_y_continuous(name=\"Total Length (mm)\",limits=c(0,700)) +\n  scale_x_continuous(name=\"Age (years)\",breaks=0:11) +\n  scale_color_manual(values=c(\"male\"=\"darkblue\",\"female\"=\"darkred\")) +\n  geom_smooth(method=\"nls\",se=FALSE,\n              method.args=list(formula=y~vb(x,Linf,K,t0),start=f.starts),\n              linewidth=1) +\n  theme(panel.grid.minor.x=element_blank(),\n        legend.position=c(0.8,0.2),\n        legend.title=element_blank())\n```\n\n::: {.cell-output-display}\n![Fit of typical von Bertalanffy growth function to male and female Lake Erie Walleye in 2014.](index_files/figure-html/fig-sex1-1.png){#fig-sex1 fig-align='center' width=384}\n:::\n:::\n\n\n&nbsp;\n\nAn alternative visualization is to put the two groups into separate panels using `facet_wrap()`.^[Simply put the grouping variable inside of `vars()` as the argument to `facet_wrap()`.] Note that color is superfluous in @fig-sex1a, but I kept it for comparison to @fig-sex1. However, mapping color to a variable will cause a legend to be produced by default. This legend, however, is redundant with the panel labels, so it was removed in `theme()` below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data=w14T,aes(x=age,y=tl,color=sex)) +\n  geom_point(size=2,alpha=0.3) +\n  scale_y_continuous(name=\"Total Length (mm)\",limits=c(0,700)) +\n  scale_x_continuous(name=\"Age (years)\",breaks=0:11) +\n  scale_color_manual(values=c(\"male\"=\"darkblue\",\"female\"=\"darkred\")) +\n  geom_smooth(method=\"nls\",se=FALSE,\n              method.args=list(formula=y~vb(x,Linf,K,t0),start=f.starts),\n              linewidth=1) +\n  theme(panel.grid.minor.x=element_blank(),\n             legend.position=\"none\") +\n  facet_wrap(vars(sex))\n```\n\n::: {.cell-output-display}\n![Fit of typical von Bertalanffy growth function to male and female Lake Erie Walleye in 2014.](index_files/figure-html/fig-sex1a-1.png){#fig-sex1a fig-align='center' width=768}\n:::\n:::\n\n\n&nbsp;\n\n# Fitting the VBGF to Multiple Groups\nMethods for fitting a von Bertalanfy growth function (VBGF) to multiple groups are detailed in @ogleIntroductoryFisheriesAnalyses2016 and @ogle_growth_2017. Thus, this methodology will only be briefly explained here.\n\nFitting the VBGF to multiple groups requires creating an expression, rather than a function, with the VBGF defined over the multiple groups. The expression below codes the VBGF using the length and age variables from the data set used here (i.e., `tl` and `age`) and assuming different parameters should be estimated for each group.^[See the linked resources for examples of how to fit the VBGF assuming situations where some parameters differ and some do not across groups.] Identifying the different groups is accomplished here by appending `[group]`, where `group` is replaced with the specific variable name that identifies the groups (i.e., `sex` here). The expression is assigned to an object name (i.e., `vbLKt` here).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvbLKt <- tl~Linf[sex]*(1-exp(-K[sex]*(age-t0[sex])))\n```\n:::\n\n\nFor use below, I identify the \"groups\" (with `unique()`) and create an object that contains the number of groups (with `length()`).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n( grps <- unique(w14T$sex) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  [1] female male  \n#R|  Levels: female male\n```\n:::\n\n```{.r .cell-code}\n( ngrps <- length(grps) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  [1] 2\n```\n:::\n:::\n\n\nThis model has six parameters -- $L_{\\infty}$, $K$, and $t_{0}$ for each of the two groups (male and female walleye). Starting values must be declared for each of these parameters. Here I find starting values from the data ignoring the groups (using `vbStarts()` as described in the previous post) and replicate those starting values for both groups.^[In some instances using the same starting values for both groups will not result in model convergence. The linked resources provide suggestions for handling those cases.] `Map` replicates the starting values in the list from `vbStarts()` with `rep` (the replicated function), the object returned from `vbStarts()`, and a numeric vector that explains how many times each parameter should be repeated (i.e., the same as the number of groups).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n( sv0 <- vbStarts(tl~age,data=w14T) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  $Linf\n#R|  [1] 591.1587\n#R|  \n#R|  $K\n#R|  [1] 0.3930388\n#R|  \n#R|  $t0\n#R|  [1] -1.544479\n```\n:::\n\n```{.r .cell-code}\n( svLKt <- Map(rep,sv0,c(2,2,2)) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  $Linf\n#R|  [1] 591.1587 591.1587\n#R|  \n#R|  $K\n#R|  [1] 0.3930388 0.3930388\n#R|  \n#R|  $t0\n#R|  [1] -1.544479 -1.544479\n```\n:::\n:::\n\n\nThe model is then fit to the data by including the VBGF expression object, `data=`, and `start=` as arguments to `nls()`. The estimated parameters may be extracted from the saved `nls()` object with `coef()`. Note that the parameters will be appended with numbers in the alphabetical order of the groups.^[Unless your chose to order the levels of the group variable differently.] Thus, in this example, it is seen that the estimated $L_{\\infty}$ for females is greater than that for males.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfitLKt <- nls(vbLKt,data=w14T,start=svLKt)\ncoef(fitLKt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|        Linf1       Linf2          K1          K2         t01         t02 \n#R|  648.2083813 574.1512545   0.3615399   0.3354067  -1.2836317  -1.9702829\n```\n:::\n:::\n\n\n&nbsp;\n\n# Model Fits from Predicted Values\nThe model fits can also be shown for predicted values, both within and outside the observed range of ages. This, however, first takes a bit of work outside of `ggplot` to prepare the relevant data.\n\nIn particular, a data frame that contains predicted mean lengths at age over the range of observed ages for all groups is needed. I being this process by finding (and assigning to an object for later use) the range of ages for each group.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\narng <- w14T |>\n  group_by(sex) |>\n  summarize(min=min(age),\n            max=max(age))\narng\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|  # A tibble: 2 × 3\n#R|    sex      min   max\n#R|    <fct>  <int> <int>\n#R|  1 female     0    11\n#R|  2 male       1    11\n```\n:::\n:::\n\n\nFrom this, I create a temporary vector of 101 ages^[Use a larger value for `length.out=` to make the line produced further below more smooth.] evenly spaced over a range of ages larger than what was observed.^[Zero was an observed age here, if not I usually make sure it is included.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\natmp <- seq(-1,12,length.out=101)\n```\n:::\n\n\nI then create a data frame that has the name of each group repeated as many times as there ages in the temporary age vector (i.e., 101 here) and then has the ages in the temporary age vector repeated for each group (i.e., twice here). Note the careful use of `each=` and `times=` in the two uses of `rep()` below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npreds <- data.frame(sex=rep(grps,each=length(atmp)),\n                    age=rep(atmp,times=ngrps))\nheadtail(preds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|         sex   age\n#R|  1   female -1.00\n#R|  2   female -0.87\n#R|  3   female -0.74\n#R|  200   male 11.74\n#R|  201   male 11.87\n#R|  202   male 12.00\n```\n:::\n:::\n\n\nPredicted mean lengths at each age for each group is then appended to this data frame by giving the fitted `nls()` object and this data frame to `predict()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npreds <- preds |>\n  mutate(ptl=predict(fitLKt,preds))\nheadtail(preds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|         sex   age       ptl\n#R|  1   female -1.00  63.17550\n#R|  2   female -0.87  90.03599\n#R|  3   female -0.74 115.66324\n#R|  200   male 11.74 568.37143\n#R|  201   male 11.87 568.61804\n#R|  202   male 12.00 568.85411\n```\n:::\n:::\n\n\nFinally, I add a fourth variable that will be `TRUE` if the age is within the range of observed ages for the group. This is accomplished with the code below that creates a new `preds` data frame. That code can be a little tricky to understand, so lets walk through a couple parts of it. First, note that the `group_by()` acts sort of like a loop here in the sense that what follows that line will be completed for the first group, then the second group, and so on. In the next snippets, consider that we are working the the \"female\" group. In this case, `unique(sex)` will return `female` such that `arng[arng$sex==unique(sex),]` will find the row of `arng` where its `sex` variable is equal to \"female\". The `$min` appended to that will extract just the value in the `min` variable of that row (so the minimum observed age for females). The `age>=arng[arng$sex==unique(sex),]$min` portion is thus asking if the `age` variable in `preds` is greater than or equal to the minimum observed age for females. If it is it will return `TRUE`, otherwise `FALSE` is returned. The second part of that `mutate()` line asks if the `age` variable in `preds` is less than or equal to the maximum observed age for females, again returning `TRUE` or `FALSE` as appropriate. Those two conditions are then connected with an `&` such that if they are both `TRUE` then a `TRUE` is returned, otherwise a `FALSE` is returned. The result is that the new `inrng` variable will be `TRUE` if the `age` variable within `preds` is within the observed range of ages for the sex given in the `sex` variable of `preds`.^[`FSA::peek()` is used here to show an evenly spaced 20 rows in the data frame. This provides more output than `headtail()` for observing the results of code.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npreds <- preds |>\n  group_by(sex) |>\n  mutate(inrng=age>=arng[arng$sex==unique(sex),]$min &\n               age<=arng[arng$sex==unique(sex),]$max)\nFSA::peek(preds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|         sex   age      ptl inrng\n#R|  1   female -1.00  63.1755 FALSE\n#R|  11  female  0.30 282.5622  TRUE\n#R|  21  female  1.60 419.6791  TRUE\n#R|  32  female  3.03 511.9351  TRUE\n#R|  43  female  4.46 566.9479  TRUE\n#R|  53  female  5.76 597.4205  TRUE\n#R|  64  female  7.19 617.9233  TRUE\n#R|  74  female  8.49 629.2802  TRUE\n#R|  85  female  9.92 636.9214  TRUE\n#R|  96  female 11.35 641.4779 FALSE\n#R|  106   male -0.48 225.8590 FALSE\n#R|  117   male  0.95 358.5543 FALSE\n#R|  128   male  2.38 440.6943  TRUE\n#R|  138   male  3.68 487.8581  TRUE\n#R|  149   male  5.11 520.7348  TRUE\n#R|  159   male  6.41 539.6122  TRUE\n#R|  170   male  7.84 552.7712  TRUE\n#R|  181   male  9.27 560.9168  TRUE\n#R|  191   male 10.57 565.5938  TRUE\n#R|  202   male 12.00 568.8541 FALSE\n```\n:::\n:::\n\n\n\nThe following code is redundant with what was done above, but it shows how the making of `preds` can be put together in one piped workflow.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npreds <- data.frame(sex=rep(grps,each=length(atmp)),\n                    age=rep(atmp,times=ngrps)) |>\n  mutate(ptl=predict(fitLKt,preds)) |>\n  group_by(sex) |>\n  mutate(inrng=age>=arng[arng$sex==unique(sex),]$min &\n               age<=arng[arng$sex==unique(sex),]$max)\nFSA::peek(preds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n#R|         sex   age      ptl inrng\n#R|  1   female -1.00  63.1755 FALSE\n#R|  11  female  0.30 282.5622  TRUE\n#R|  21  female  1.60 419.6791  TRUE\n#R|  32  female  3.03 511.9351  TRUE\n#R|  43  female  4.46 566.9479  TRUE\n#R|  53  female  5.76 597.4205  TRUE\n#R|  64  female  7.19 617.9233  TRUE\n#R|  74  female  8.49 629.2802  TRUE\n#R|  85  female  9.92 636.9214  TRUE\n#R|  96  female 11.35 641.4779 FALSE\n#R|  106   male -0.48 225.8590 FALSE\n#R|  117   male  0.95 358.5543 FALSE\n#R|  128   male  2.38 440.6943  TRUE\n#R|  138   male  3.68 487.8581  TRUE\n#R|  149   male  5.11 520.7348  TRUE\n#R|  159   male  6.41 539.6122  TRUE\n#R|  170   male  7.84 552.7712  TRUE\n#R|  181   male  9.27 560.9168  TRUE\n#R|  191   male 10.57 565.5938  TRUE\n#R|  202   male 12.00 568.8541 FALSE\n```\n:::\n:::\n\n\n&nbsp;\n\n@fig-sex2 is created with the code below that largely combines similar code from the previous post and the use of `color=` provided above. In brief, `geom_point()` is used to add points at the observed lengths at age, the first `geom_line()` adds the fitted models as dashed lines from the predicted mean lengths at **all** ages in `preds`, and the second `geom_line()` adds the fitted models solid lines from the predicted mean lengths **only** at observed ages for each group.^[Note the use `filter()` in the second `geom_line()` so that only data for which `inrng==TRUE` is used.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data=w14T,aes(x=age,y=tl,color=sex),\n             size=2,alpha=0.3) +\n  geom_line(data=preds,aes(x=age,y=ptl,color=sex),\n              linewidth=1,linetype=\"dashed\") +\n  geom_line(data=filter(preds,inrng),aes(x=age,y=ptl,color=sex),\n              linewidth=1) +\n  scale_y_continuous(name=\"Total Length (mm)\",limits=c(0,700)) +\n  scale_x_continuous(name=\"Age (years)\",breaks=0:11) +\n  scale_color_manual(values=c(\"male\"=\"darkblue\",\"female\"=\"darkred\")) +\n  theme(panel.grid.minor.x=element_blank(),\n        legend.position=c(0.8,0.2),\n        legend.title=element_blank())\n```\n\n::: {.cell-output-display}\n![Fit of typical von Bertalanffy growth function to male and female Lake Erie Walleye in 2014. The dashed lines show the model fits outside the range of observed ages for each sex.](index_files/figure-html/fig-sex2-1.png){#fig-sex2 fig-align='center' width=384}\n:::\n:::\n\n\n&nbsp;\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}